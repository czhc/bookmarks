# Sprint 3 - 06/14

## Ethereum

- [x] EthCatHerders: [London Upgrade Overview](https://medium.com/ethereum-cat-herders/london-upgrade-overview-8eccb0041b41)
    * EIP 1559: introduces _base fee_ to track network gas price based on demand for blockspace to simplify gas price estimations for UX
    * EIP 1559: also introduces new txn type: set _max fee payable_ and _max fee to miner_, with balance refunded
    * EIP2918: Adds opcode `BASEFEE` for 1559
    * EIP3529: Reduces gas refunds for `SSTORE` and `SELFDESTRUCT`. Gas refunds contribute to variance in block execution, and this reduces block size variance coming from 1559.
    * EIP3541: starts reserving prefix bytes `0xEF` for future 3540 semantics.
    * EIP3554: delays difficulty bomb to Dec 1 2021.

## L2, Sidechains and Scaling Solutions

- [x] [Tracer](https://tracer.finance/radar/arbitrum-in-under-10/): Arbitrum in under 10 minutes
    * Architecture
        * Component of Arbitrum in L1 is the **EthBridge** - referees the Arbitrum Rollup
        * Inbox/outbox accepts txns from users, L1 contracts, full nodes
        * AVM is function of EthBridge, is L1-L2 gateway to perform comutations
        * ArbOS runs on AVM, handles smart contract execution completely on L2 similar to EVM contracts on EVM.
    * Rollup
        * Message ordering in inbox determines result of txn
        * Confirming resuts on txn
        * **only 1 validator needed to force correction**
        * block proposal shave a deadline for confirmation
        * validator disagreeing with the block will propose own correction block for rewards after fraud proofs.
    * Staking:
        * Permissionless staking: stake on any block
        * Stacking is locked until the block is confirmed
        * block confirmation includes every block between _most recent unconfirmed block until your current staked block_
        * dynamic staking amount - includes base + (temporary) multiplied exponential factor during network attacks
    * Challenge:
        * Challenges is an interactive, multiround dissection on L2 and proof on L1
        * proof/defending a challenge is to execute N instructions on the preceding block to show the resulting state is equal to proposed block stake
        * N instructions are divided in equal sizes wrt. Arb gas
        * Identiy subsegment where defender and contender disagrees - **this subsegment's instruction is sent to L1 to execute and decide on winner**
        * loser has stake slashed and remainder of stake is awarded to the winner.
        * other validators are ab;e to determine result of dispute before dispute is final to create soft forks, and rollups can be submitted.
    * Validators:
        * Active: propose new blocks to add to chain. only 1 honest active validator is required per chain
        * Defensive: watches rollup and acts on dishonest behavior by proposing a correct block or stake on correct blocks
        * Watch tower: watches and alerts defensive validators to propose corrections
    * Full nodes:
        * does not require knowledge of rollup protocols
        * serves as txn aggregator and compressor to reduce gas costs
    * Sequencer Mode:
        * optional component - full node with additional privilege of txn ordering
        * instnaely guarantee result of txn - because **inbox txn order changes output result**
        * with a sequencer, the inbox is split into two: with and without sequencers.
        * sequencer can specify block # and timestamp when sending messages to inbox
        * \# of backdate blocks is equals # of blocks needed for Ethereum finality.
        * with sequencers, txns will achieve finality x blocks faster
        * malicious sequencers can censor user txns by forcing them into regular inbox and frontrunning them. **Choice of sequencer operators matters**
    * ArbGas / Fees
        * provide predictable measure of time to validate result of computation
        * can be used as a block validity check to ensure the net gas consumed by disputed block is the same



## Defi Security

- [ ] OpenZeppelin [ReEntrancy Guard](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/security/ReentrancyGuard.sol)

### Pause Controls in Smart Contracts

- [x] Rex Hygate: [Pause Control](https://rex2.medium.com/pause-control-and-iron-finance-9b2d2e70f2a9) and Iron Finance
    * DefiSafety to include **transparency of pause controls** as part of reviews
    * All protocols should explain their pause capability - in terms of scope of pause, trigger/controls (e.g. multisig), breaksafe decision and testing procedures.
    * Pause capabilities to be _fire drilled_.
- [x] OpenZeppelin [ERC20Pausable](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/extensions/ERC20Pausable.sol) standard
    - [x] How to make a [Pausable ERC20](https://medium.com/coinmonks/how-to-make-a-pausable-erc20-token-9fb1ab5dc877)
    * `Paused` tokens are _only transferrable by the token contract owner_. The token needs to be `Ownable` first to assign an owner.
    * Pausing is used to stop all txns related to this token including swaps on DEXs.
    * `nonPausable` is irreversible - after this even the token owner is not able to pause.
- [x] Badger: [Early Timelock Withdraw exploit](https://medium.com/badgerdao/sgt-early-timelock-withdraw-post-mortem-f4ac0d79ee36) from SGT incident
    * Timelock contracts e.g. [Badger](https://github.com/Badger-Finance/badger-system/blob/master/contracts/badger-timelock/SmartTimelock.sol), [Compound](https://github.com/compound-finance/compound-protocol/blob/master/contracts/Timelock.sol) are used to implement set time delays before make an action accessible by the user. This can be used for vesting [[Badger Vesting](https://github.com/Badger-Finance/badger-system/blob/master/contracts/badger-timelock/SmartVesting.sol) - uses additional `onlyGovernor` multisig] etc.
    * Badger `SmartTimelock``call`: allows attacker to grant approval to another contract to pull funds.

- [ ] [The DAO hack](http://hackingdistributed.com/2016/06/18/analysis-of-the-dao-exploit/): Re-entrancy atack
    * [The DAO](https://www.gemini.com/cryptopedia/the-dao-hack-makerdao) was a decentralized, ETH-based investment DAO to collect funds, approve proposals and ivnest in entities.
    * 150M of ETH was crowdfunded. After the hack , ETH was hardforked to refund the stolen ETH resulting in ETC (retains old ETH and hacked chain) and ETH.
    * Hardfork rolled back network history to before the DAO hack and reallocated the DAO's ether to a new smart contract for withdrawing their funds. A hardfork required miners, exchanges and node operators to coordinate to upgrade.

## Solidity, etc.

- [x] [Docs](https://docs.soliditylang.org/en/v0.8.1/units-and-global-variables.html#special-variables-and-functions): Special Variables and Functions: `block`, `msg`, `tx`
    * `this` is referring to the current contract instance
- [x] [`address`](https://docs.soliditylang.org/en/v0.8.1/types.html?highlight=address#address). `address payable` has `transfer` and `send`. plain `address` cannot container ETH. `address payable` can be converted to `address`, but reverse conversion must be explicit `payable(<address>)`
    * `function`s and `address`es declared as `payable` can **receive** ETH. sending ETH into functions without `payable` will throw an error. functions that **send** ETH do not need `payable`
    * `payable` is a **modifier**, i.e. interface.
    * `ownable` modifier [[src: OpenZep](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/Ownable.sol)] provides ownership functions including `onlyOwner` modifiers and public functions e.g. `renounceOwnership()`, `transferOwnership`, and private functions `_setOwner`.
* `constructor()` is only called on contract deployment, once.
* functions declare as `view` do not modify state. state modification includes: modifying state vars, emitting events, creating other contracts, selfdestruct, sending ETH, calling non-view or non-pure functions, low-level calls etc. and will throw warning when compiled.

* Smart contracts cannot be paused on a protocol, but pausable using code/feature flags.
* smart contrats can be permanently disabled / delete current state with `selfdestruct`
    * `selfdestruct` requires a `to` address: the ETH balance are withdraw into this `to` address.
    * _You can still send ETH into a destroyed contract_, but no option to withdraw
* Mappings for storing [k,v] pairs
    * mappings are defined as `mapping(key_type => value_type)`. also creates getters. default values for key and value types apply.
    * mappings of mappings: `mapping(uint => mapping(uint => bool))`
* Structs for more than [k,v] pairs - you can store more information in an "account" e.g. timestamp, etc.
    * do only the most necessary functions on the blockchain and leave everythign else offchain
    * `mapping(address => MyStruct) someMapping` allows `someMapping[ADDRESS].attribute`
    * **local variables which are complex** require a `memory` declaration e.g. `Payment memory payment` creates a local variable `payment` of the type `Payment` struct
    * cannot return Structs on solidity, have to manuall unpack attributes
    * Struct attributes should be preceeded with `_` e.g. `struct Foo { uint _id }`
* Re-Entrancy / Recursive calling: **Always interact with _external addresses LAST_**e.g. `.transfer` should be the last instruction in a function.
    - [x] [Checks Effects Interactions](https://fravoll.github.io/solidity-patterns/checks_effects_interactions.html)
        * reduce attack surface for malicious contracts hijacking control flow
        * EVM is not concurreny, when calling an external add, the contract is also transferring control flow to the external entity, and _can now control the flow and execute inherent code_
            * notice that `.tranfer` is invoked by the `_to` address, not `this`.
        * **re-entrancy**: external contract is re-entering initial contract **before the first function call is finished**
            * repeated invoke functions that should only be executed once. see the DAO hack
        * Use CEI pattern when:
            1. it is unavoidable to hand over control to external entity
            2. guard functions against re-entrancy
        * Principle: Update all state variables **before external interaction**- optimistic accounting: all effects are written down before taking place.
            1. **checks**: does the user have sufficient balance
            2. **effects**: apply changes to state variable (balance mapping)
            3. **interactions**: call `.transfer` to `msg.sender`
        * without CEI: if I comes before E, and instead of `transfer()`, a lowlevel opcode `call.value()` is used - reentrancy is possible.
            * control flow is passed to the external contract, and it can call `withdraw()` again before first invocation is finished, without being intercepted by `withdraw()` check -- since state variable is not updated yet at the time of `call()`
* Assert to check invariants - states in which vars, or contracts should never reach e.g. out of bounds
    * e.g. `uint64` types only allow max value of 2^64. sending more ETH into a `uint64` balance will cause sent funds to disappear because the max values will rollover.
    * use `assert` to **throw exceptions** e.g. when casting types, verifying/confirming state changes
* `require` should be used for both:
    * validation checks
    * confirmation of change, esp for interactions with other contracts or 3rd party
* Fallback functions: anonymous functions in Solidity 0.6, or separated to `receive()` (receives money) and `fallback()` (smart contract interactions without ETH)
    * use fallback functions e.g. `receive()` to alias a deposit function etc.
    * fallbacks will also print the final function being called

* Reading values is free. Using `view` (reads state variables) and `pure` (does not read state variables)
    * `pure` functions can be used for type manipulations, calculations, interface functions etc. since they don't need to access a state variable.

* `calldata` is where data from external calls to functions is stored.
* `external` vs `public`: in public functions, arguments is copied to memory where as external functions read directly from `calldata` - reducing memory allocated to function calls.
    * `public` - accessed by all
    * `external` - cannot be accessed internally
    * `internal`- only by this contract _and other contracts deriving it_
    * `private` - only by this contract

* `_;` statements in modifiers are used to return the call control to the invoking function

* `import "https://..."` to import remote smart contracts
* contracts can be inherited from each oether. Contract inherits other Contract. e.g. `Allowance is Ownable, SharedWallet is Allowance`

* use `event`s extensively

* `enum` types: `enum myEnum{Foo, Bar, Baz}`

* how to call methods in another contract (that is not inherited):

    ```solidity
        address(OtherContract).call{ value: _TXN message value_ }(abi.ecodeWithSignature("THE_METHOD_TO_CALL(argument)", arg1, arg2 etc...));
    ```

* [`SafeMath`](https://github.com/ConsenSysMesh/openzeppelin-solidity/blob/master/contracts/math/SafeMath.sol) used to be relevant before solidity 0.8 due to overflows. with 0.8.0 `SafeMath` is not needed anymore:
    * `.add(), .mul()` can now be written as `x+y, x*y`
    * prev, using SafeMath declaration `using SafeMath for uint`

* override functions using `override` modifier
- [ ] [Secure Ether Transfer](https://fravoll.github.io/solidity-patterns/secure_ether_transfer.html):
    * secures ETH transfer from between contracts:
    * in earlier vesions of solidity, transfer are done using : `address.send(amount)` but send does not propagate errors, and gas must be manually specified.
    * a new transfer fucntion for Solidity 0.4.13 `transfer(amount)` was added
    * use SET when:
        * transfer ETH from contract to another address
        * not sure which method of transfer `call`, `send`, `transfer` is suitable
        * guard against `re-entrancy` attacks
- [ ] Solidity [Security Considerations](https://docs.soliditylang.org/en/develop/security-considerations.html?highlight=check%20effects#pitfalls)

- [ ] Consensys: Smart Contract [Known Attacks](https://consensys.github.io/smart-contract-best-practices/known_attacks/)

- [ ] [guylando](https://github.com/guylando/KnowledgeLists/blob/master/EthereumSmartContracts.md): Smart Contract security recommendations


- [ ] Solidity v0.8 breaking changes:
    * arithmetic ops reverts on underflow and overflow. escape with `unchecked {}`
    * remove need for `SafeMath` operations e.g. `mul()`, `add()`
    * exponention is right-associative: `a**b**c` = `a**(b**c)`
    * Failed asserts, division by zero and overflows now throw `revert` opcode and call `Panic(uint256)`.
    * byte array in storage accessed with incorrect length throws panic
    * constant vars used in intermediate experssions will be rounded, not using arbitrary precision
    * `byte` type is removed, change to `byte1`
    * explicit conversation from negative and non-neg literals larger than `uint160` to `address` are disallowed


## Smart Contracts* and Dev Resources

- [x] [Gnosis Safe Multisig](https://blog.gnosis.pm/announcing-the-gnosis-safe-multisig-launch-a5d4ab17bd01) - create multisig wallets
    * use by consensys, synthetix, ens, kuber, bal, yearn, sushi, aave, 1inch.
    * Gnosis Safe features: multisig, defi integration, privacy, NFT support, gasless signature, open source.
    - [x] [Multisig Launch](https://blog.gnosis.pm/announcing-the-gnosis-safe-multisig-launch-a5d4ab17bd01) details
    - [x] [Safe Apps](https://blog.gnosis.pm/introducing-gnosis-safe-apps-faef908f69c6) launch
        * Direct interaction with Ethereum apps direction from Safe Multisig UI. Nothing special, you can import dApps into the Safe Apps UI: _makes Safe Multisig a browser into the “internet of value”_
    * MultiSig wallets:
        * everyone can deposit funds, but only owners can execute txns from wallet
        * Add/remove/replace owners require a threshld of owners for confirmation.
        * hardware wallet integration
        * import/export external Ethereum V3 format accounts
        * txn simulation
        * offline signing
    * Gnosis testnet on [Rinkeby](https://rinkeby.gnosis-safe.io/app/)
    * Changing owners is a txn
    * Setting spending limits by asset-amount-beneficiary. Beneficiary is any contact listed in the address book. Allowed amount can be reset over a time period.
    * **Approving Vault transactions:** Safe transaction approvals requests for individual signatures, not txns. Safe owners can choose to only **sign for approval** without paying to **execute the transaction**. But 1 owner is required to actually _approve the txn_, and will have to pay for gas.
    * Incomplete transactiosn will show in queue as Need Confirmations. Confirmations can be rejected while pending.
- [x] Why do dApps/clients communicate over [RPC](https://ethereum.stackexchange.com/questions/85245/why-do-blockchain-networks-like-ethereum-utilize-json-rpc-calls-and-not-rest-api)? Client are invoking procedures between each other, instead of managing resources via HTTP. Separate proposal for Eth clients to [use GraphQL](https://eips.ethereum.org/EIPS/eip-1767)
- [x] Yearn Vesting [Escrow contract](https://github.com/banteg/yearn-vesting-escrow) based on CurveDAO and Aragon Voting App - vesting contracts
    * [VestingEscrowSimple](https://github.com/banteg/yearn-vesting-escrow/blob/master/contracts/VestingEscrowSimple.vy#50) - simple vesting for any ERC20 token on init only.
- [x] [Solidity by example](https://docs.soliditylang.org/en/develop/solidity-by-example.html) - Example contracts
- [x] [Gelato v1](https://medium.com/gelato-network/introducing-gelato-v2-the-most-reliable-way-to-automate-your-ethereum-smart-contracts-73cd0010599e): Bots for Automation in Ethereum
    * Automatic Chi minting: [repo](https://github.com/gelatodigital/gelato-chi)
    * DCA buying ETH from uniswap: [repo](https://github.com/gelatodigital/gelato-uniswap)
    * Users/Task Owners (**Providers**) deposit ETH to network of relay servers (**Executors**) to execute **Tasks**
    * **External Providers**: pay/deposit ETH on gelato to abstract from end-user experieience
    * **Self Providers**: end-users, must deposit ETH on gelato for future transactions.
    * `GelatorUserProxy`: proxy wallet. can be a Gnosis Safe or Maker DSProxy
    * Step 1: Provider creates a proxy contract that will be used to interface with Gelato network.
    * Step 2: Deposit ETH to Gelato Core, set Gelato Execution Network and whitelist provider's proxy: [code](https://github.com/gelatodigital/gelato-uniswap/blob/master/demo/Part-1_Gelato_User/step2-user-proxy-setup.js#L72)
    * Step 3: Create new `Action` with ABI, deposit ETH, op to call from Step 1 proxy
    * Step 4: create Gelato `Tasks` (Conditions + Actions). for DCA-ing ETH on uniswap:
        * Condition: every 2 minutes [contract](https://github.com/gelatodigital/gelato-uniswap/blob/master/contracts/gelato_conditions/ConditionTimeStateful.sol)
        * Action: Trade 1 DAI for WETH [contract](https://etherscan.io/address/0x7a250d5630b4cf539739df2c5dacb4c659f2488d#code)
    *  To complete requires 2 txn: approve Proxy to move DAI from wallet, then Submit task to GelatoCore contract.
    *  Task definition: [code](https://github.com/gelatodigital/gelato-uniswap/blob/master/demo/Part-1_Gelato_User/step3-submit-task-uniswap.js#L170)
    *  Submit task from User Proxy, to gelato network (via GelatoProvider): [[code](https://github.com/gelatodigital/gelato-uniswap/blob/master/demo/Part-1_Gelato_User/step3-submit-task-uniswap.js#L305)]
- [x] [Gelato v2](https://medium.com/gelato-network/introducing-gelato-v2-the-most-reliable-way-to-automate-your-ethereum-smart-contracts-73cd0010599e)
    * Service Standards - set of functions for specific sets of use cases, no longer one size fits all
    * Removes required proxy contracts to save gas costs
    * Off-chain logic to pre-compute data and save gas
    * No pre-deposits and multi-asset deposits
    * metatxn support: users signs offchain message to Gelato Service Relay, pulled by Executors
    * Bot coordination - allocate slots to different Executor operators to prevent front-running
    * on [EIP-2535 Diamond Standard](https://www.youtube.com/watch?v=ttv4ecXykfM)

- [x] Buidler - productivity/dev [tools](https://medium.com/nomic-labs-blog/how-to-get-started-with-buidler-68beb6b9bb04)
    * define custom task builders e.g. adhoc tasks, testing etc. custom scripts are stored in `buidler.config.js`

### Standards and Design Patterns
- [ ] [Upgradable Contracts](https://ethereum-blockchain-developer.com/110-upgrade-smart-contracts/00-project/)
- [ ] [VomTom](https://www.youtube.com/watch?v=YpEm9Ki0qLE): Smart Contract Upgrades and Proxy Patterns
    1. Eternal Storage - separate storage from logic (address)
    2. Proxy Contract - keep user-facing address, and/or storage
    3. Diamond Standard
    4. Metamorphic Smart Contracts - uses [create2](https://docs.openzeppelin.com/cli/2.8/deploying-with-create2)
        * without CREATE2: contract address is **computed from deployed address and nonce**
        * with CREATE2: instruct EVM to reserve a contract address. You can then selfdestruct and redeploy new contracts to the same address

- [x] EIP 2535: [Diamond Standard](https://eips.ethereum.org/EIPS/eip-2535)
    * Smart contracts with no size limit (above 24KB) and is modular and gas-eficient
    * Contracts can be upgraded on the fly without redeploying - single address for unlimited contract functionality
    * Standardize contract interfaces and implementation details: code and data architecture
    * A diamond is a contract with external functions that are supplied by contracts called facets.
    * Facets are separate, independent contracts that can share internal functions, libraries and state variables.
- [x] Gelato Dev Meetup: [video](https://www.youtube.com/watch?v=ttv4ecXykfM)
    * Core component: **fallback functions** delegates functions from **facet** contracts.
    * Function-to-facet mapping (bytes => address) allow upgradeability without proxies, just changes ToFacet mapping.
    * Does not support solidity built-in _state variable layout_ : replaced with **Diamond Storage**, or storage contracts.
    * **DiamondCut** and **Loupe** trackes state changes and function-facet maps to introspect diamond
    * inter-facet function calls done as _internal functions_
    - [x] Diamond contract explorer: [louper.dev](https://louper.dev/) - tracks history of facet modifications
    - [x] ToB: how the Diamond standard [falls short](https://blog.trailofbits.com/2020/10/30/good-idea-bad-design-how-the-diamond-standard-falls-short/)
        * working upgradeability stndard should include: upgrade procedures, on-chain mitigitaions against function shadowing and collisions, list of associated risks, integration tests etc.
        * (1) Lookup table - delegatecalls to multiple contract implementation. used in Colony Network [Delegate Proxy](https://colony.io/dev/docs/colonynetwork/docs-upgrade-design) pattern
        * (2) Aribitrary storage pointer - assigns storage pointer to arb location.
        * Storage pointer risks - collisions are still possible
        * Function shadowing - functions in proxy that shadow functions in delegate. - use slither-check-upgradeability for checking shadowing
        * No-contract existence check
        * unnecessary vocabulary change
    - [ ] [Response](https://dev.to/mudgen/addressing-josselin-feist-s-concern-s-of-eip-2535-diamond-standard-me8)

- [ ] OpenZep: Using [`CREATE2`](https://docs.openzeppelin.com/cli/2.8/deploying-with-create2)
      * Predict/precompute the address that a contract will be deployed

- [ ] OpenZep: [Deploying and interacting](https://docs.openzeppelin.com/learn/deploying-and-interacting) with smart contracts
- [ ] ToB: How [contract migration](https://blog.trailofbits.com/2018/10/29/how-contract-migration-works/) works
- [ ] ToB: Contract upgrade [anti-patterns](https://blog.trailofbits.com/2018/09/05/contract-upgrade-anti-patterns/)
- [ ] Colony Network [Delegate Proxy design pattern](https://colony.io/dev/docs/colonynetwork/docs-upgrade-design)
- [ ] OpenZep: Upgradeability using [Unstructured Storage](https://github.com/OpenZeppelin/openzeppelin-labs/tree/ff479995ed90c4dbb5e32294fa95b16a22bb99c8/upgradeability_using_unstructured_storage)
- [ ] [Gemini](https://www.youtube.com/watch?v=sPUBUcjdEzk) upgradeability implementation
- [ ] [Slither](https://github.com/crytic/slither/wiki/Upgradeability-Checks): Upgradeability checks

- Maker's DSProxy
    - [ ] [Short intro DSProxy](https://medium.com/defi-saver/a-short-introduction-to-makers-dsproxy-and-why-we-l-it-c88932595be)
    - [ ] [DSProxy docs](https://docs.makerdao.com/build/dai.js/advanced-configuration/using-ds-proxy)
- DefiSaver [Smart Savings](https://help.defisaver.com/smart-savings/what-is-the-user-wallet)
- Oasis [Direct Proxy](https://oasisdex.com/docs/guides/use-proxy)


### Peer-to-peer payments

- [x] [Superfluid](https://medium.com/superfluid-blog/superfluid-streams-5cc5141dd8a7) - money streaming
    * streaming funds from wallet to wallet, continuously until manual stop or until balance is 0
    * set flow rate of tokens from hourly - yearly, but pro-rated per second. Streams do not cost gas, only when open/close/edit
    * Source amount is not locked and available in wallet.
    * Possible using wrapped ERC20s - SuperTokens
    - [x] Constant [FLow Agreement](https://docs.superfluid.finance/superfluid/docs/constant-flow-agreement)
    * deployed on Polygon and xDAI
    * [Partnership](https://medium.com/ethereum-push-notification-service/programmable-money-2-0-meets-epns-4a2f52dccb32) with EPNS

- [x] Superfluid: Dawn of [Programmable Cashflows](https://medium.com/superfluid-blog/the-dawn-of-programmable-cashflows-2d50edae05cb)
    * transfer any token or digital asset on-chain using predefined rules ("agreements")
    * transfer X amount per T period, but value is paid per-second, realtime without needing gas or txns.
    * Agreements are (1) Money streaming or (2) Rewards distributions
    * Register smart conracts as _SuperApps_, reacts to stream events.
    - [x] [UI](https://app.superfluid.finance/)
        * Sender deposits asset, create stream for asset with receiver, amount and interval. No swapping in streams. Sender can send multiple streams/assets to same receiver.
        * realtime accrual in receiver dashboard. **receiver can cancel a stream**. receiver can share link to stream.
        * Currencies in SF are wrapped as [Super Tokens](https://docs.superfluid.finance/superfluid/protocol-tutorials/primitives#2-super-tokens) (ERC777 - tokens that react to events using callbacks)
        * Can't seem to set an End time - only until the wallet balance ends. Use Gelato instead


- [ ] [MetaTxn](https://metatx.io/) for recurring payments, powers Gitcoin Grants - from griffith [token-subscriptions](https://github.com/austintgriffith/token-subscription)
    * MetaTxns are txns that are signed and delegated to a 3rd party to put on-chain.
    - [ ] [overview - youtube](https://www.youtube.com/watch?v=6r3SqCcEVU4)
    - [x] A.Griffith: Ethereum [Meta Transactions](https://medium.com/@austin_48503/ethereum-meta-transactions-90ccf0859e84)
        * First-time gas to be paid by _3rd party (desktop miners)_.
        * User signatures are stored in browser to remove initial barrier of wallet adoption.
        * MetaTxs are similar to Eth txns, but with:
            *  Data: encoded info detailing list of actions including hash of function name to call and args
            *  **Reward:** to be paid to desktop miners in ETH or tokens, paid from an identity proxy contract, not directly from user account
            *  Requirements: extended requirements e.g. time/chronological check.
        *  MetaTxs are sent to a secondary network, and the network validates and interfaces with the blockchain. A proxy contract receives the metatx processes the instructions, pays the miner and execute metatx commands.
    *  Identity Proxy Contract: onchain proxy contract to receive metatx from 3rd party and call metatxn instructions.
    - [ ] [ZK Labs](https://zklabs.io/audits/tokensub.html) audit

- [x] [ERC948](https://gitcoin.co/blog/technical-deep-dive-architecture-choices-for-subscriptions-on-the-blockchain-erc948/): Architecture Choices for Subscriptions on the Blockchain
    * Arch 1: User-driven txns completely on-chain between pariticipants. payer/subscriber creates subscription with payee/provider and payment interval, approves transferFrom() contract. Payee/provider stores events and executes subscription.
    * Arch 2: Limited Delegation Txns. Uses a _Processor_ with approval to process txn on behalf of provider. Processors are any form of delegated 3rd party : single, multiSig or address whitelist.
    * Arch 3: Meta Txns: signed message of intent from user, delgated to processor, reused recurringly.
        * payer/subscriber creates subscription, approve subscription contract, and signature. signed message is given to payee/provider.
        * payee/provider stores signed message and calls executeSubscription at given intervals, or pass the payer signature  to a _processor_ to execute on payee's behalf
        * basically double-delegation using signed messages.
        * use for any type of recurring action and N processors without explicit approval
- [x] [Groundhog Payments](https://groundhog.network/) using [EIP-1337]()-- looks inactive.
