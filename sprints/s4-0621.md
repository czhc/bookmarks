# Sprint 4 - 06/21

## Ethereum

- [x] EthCatHerders: [London Upgrade Overview](https://medium.com/ethereum-cat-herders/london-upgrade-overview-8eccb0041b41)
    * EIP 1559: introduces _base fee_ to track network gas price based on demand for blockspace to simplify gas price estimations for UX
    * EIP 1559: also introduces new txn type: set _max fee payable_ and _max fee to miner_, with balance refunded
    * EIP2918: Adds opcode `BASEFEE` for 1559
    * EIP3529: Reduces gas refunds for `SSTORE` and `SELFDESTRUCT`. Gas refunds contribute to variance in block execution, and this reduces block size variance coming from 1559.
    * EIP3541: starts reserving prefix bytes `0xEF` for future 3540 semantics.
    * EIP3554: delays difficulty bomb to Dec 1 2021.

## L2, Sidechains and Scaling Solutions

- [x] [Tracer](https://tracer.finance/radar/arbitrum-in-under-10/): Arbitrum in under 10 minutes
    * Architecture
        * Component of Arbitrum in L1 is the **EthBridge** - referees the Arbitrum Rollup
        * Inbox/outbox accepts txns from users, L1 contracts, full nodes
        * AVM is function of EthBridge, is L1-L2 gateway to perform comutations
        * ArbOS runs on AVM, handles smart contract execution completely on L2 similar to EVM contracts on EVM.
    * Rollup
        * Message ordering in inbox determines result of txn
        * Confirming resuts on txn
        * **only 1 validator needed to force correction**
        * block proposal shave a deadline for confirmation
        * validator disagreeing with the block will propose own correction block for rewards after fraud proofs.
    * Staking:
        * Permissionless staking: stake on any block
        * Stacking is locked until the block is confirmed
        * block confirmation includes every block between _most recent unconfirmed block until your current staked block_
        * dynamic staking amount - includes base + (temporary) multiplied exponential factor during network attacks
    * Challenge:
        * Challenges is an interactive, multiround dissection on L2 and proof on L1
        * proof/defending a challenge is to execute N instructions on the preceding block to show the resulting state is equal to proposed block stake
        * N instructions are divided in equal sizes wrt. Arb gas
        * Identiy subsegment where defender and contender disagrees - **this subsegment's instruction is sent to L1 to execute and decide on winner**
        * loser has stake slashed and remainder of stake is awarded to the winner.
        * other validators are ab;e to determine result of dispute before dispute is final to create soft forks, and rollups can be submitted.
    * Validators:
        * Active: propose new blocks to add to chain. only 1 honest active validator is required per chain
        * Defensive: watches rollup and acts on dishonest behavior by proposing a correct block or stake on correct blocks
        * Watch tower: watches and alerts defensive validators to propose corrections
    * Full nodes:
        * does not require knowledge of rollup protocols
        * serves as txn aggregator and compressor to reduce gas costs
    * Sequencer Mode:
        * optional component - full node with additional privilege of txn ordering
        * instnaely guarantee result of txn - because **inbox txn order changes output result**
        * with a sequencer, the inbox is split into two: with and without sequencers.
        * sequencer can specify block # and timestamp when sending messages to inbox
        * \# of backdate blocks is equals # of blocks needed for Ethereum finality.
        * with sequencers, txns will achieve finality x blocks faster
        * malicious sequencers can censor user txns by forcing them into regular inbox and frontrunning them. **Choice of sequencer operators matters**
    * ArbGas / Fees
        * provide predictable measure of time to validate result of computation
        * can be used as a block validity check to ensure the net gas consumed by disputed block is the same



## Defi Security

- [x] OpenZeppelin [ReEntrancy Guard](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/security/ReentrancyGuard.sol)
- [x] Smart Contract Weakness [(SWC) registry](https://swcregistry.io/)
   * from [EIP1470](https://github.com/ethereum/EIPs/issues/1469)
- [ ] [Mythril](https://github.com/ConsenSys/mythril): Security analysis tool for EVM bytecode
- [ ] [Ethernaut](https://ethernaut.openzeppelin.com/): security playground

### Pause Controls in Smart Contracts

- [x] Rex Hygate: [Pause Control](https://rex2.medium.com/pause-control-and-iron-finance-9b2d2e70f2a9) and Iron Finance
    * DefiSafety to include **transparency of pause controls** as part of reviews
    * All protocols should explain their pause capability - in terms of scope of pause, trigger/controls (e.g. multisig), breaksafe decision and testing procedures.
    * Pause capabilities to be _fire drilled_.
- [x] OpenZeppelin [ERC20Pausable](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/extensions/ERC20Pausable.sol) standard
    - [x] How to make a [Pausable ERC20](https://medium.com/coinmonks/how-to-make-a-pausable-erc20-token-9fb1ab5dc877)
    * `Paused` tokens are _only transferrable by the token contract owner_. The token needs to be `Ownable` first to assign an owner.
    * Pausing is used to stop all txns related to this token including swaps on DEXs.
    * `nonPausable` is irreversible - after this even the token owner is not able to pause.
- [x] Badger: [Early Timelock Withdraw exploit](https://medium.com/badgerdao/sgt-early-timelock-withdraw-post-mortem-f4ac0d79ee36) from SGT incident
    * Timelock contracts e.g. [Badger](https://github.com/Badger-Finance/badger-system/blob/master/contracts/badger-timelock/SmartTimelock.sol), [Compound](https://github.com/compound-finance/compound-protocol/blob/master/contracts/Timelock.sol) are used to implement set time delays before make an action accessible by the user. This can be used for vesting [[Badger Vesting](https://github.com/Badger-Finance/badger-system/blob/master/contracts/badger-timelock/SmartVesting.sol) - uses additional `onlyGovernor` multisig] etc.
    * Badger `SmartTimelock``call`: allows attacker to grant approval to another contract to pull funds.

- [ ] [The DAO hack](http://hackingdistributed.com/2016/06/18/analysis-of-the-dao-exploit/): Re-entrancy atack
    * [The DAO](https://www.gemini.com/cryptopedia/the-dao-hack-makerdao) was a decentralized, ETH-based investment DAO to collect funds, approve proposals and ivnest in entities.
    * 150M of ETH was crowdfunded. After the hack , ETH was hardforked to refund the stolen ETH resulting in ETC (retains old ETH and hacked chain) and ETH.
    * Hardfork rolled back network history to before the DAO hack and reallocated the DAO's ether to a new smart contract for withdrawing their funds. A hardfork required miners, exchanges and node operators to coordinate to upgrade.

## Solidity, etc.

- [x] [Docs](https://docs.soliditylang.org/en/v0.8.1/units-and-global-variables.html#special-variables-and-functions): Special Variables and Functions: `block`, `msg`, `tx`
    * `this` is referring to the current contract instance
- [x] [`address`](https://docs.soliditylang.org/en/v0.8.1/types.html?highlight=address#address). `address payable` has `transfer` and `send`. plain `address` cannot container ETH. `address payable` can be converted to `address`, but reverse conversion must be explicit `payable(<address>)`
    * `function`s and `address`es declared as `payable` can **receive** ETH. sending ETH into functions without `payable` will throw an error. functions that **send** ETH do not need `payable`
    * `payable` is a **modifier**, i.e. interface.
    * `ownable` modifier [[src: OpenZep](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/Ownable.sol)] provides ownership functions including `onlyOwner` modifiers and public functions e.g. `renounceOwnership()`, `transferOwnership`, and private functions `_setOwner`.
* `constructor()` is only called on contract deployment, once.
* functions declare as `view` do not modify state. state modification includes: modifying state vars, emitting events, creating other contracts, selfdestruct, sending ETH, calling non-view or non-pure functions, low-level calls etc. and will throw warning when compiled.

* Smart contracts cannot be paused on a protocol, but pausable using code/feature flags.
* smart contrats can be permanently disabled / delete current state with `selfdestruct`
    * `selfdestruct` requires a `to` address: the ETH balance are withdraw into this `to` address.
    * _You can still send ETH into a destroyed contract_, but no option to withdraw
* Mappings for storing [k,v] pairs
    * mappings are defined as `mapping(key_type => value_type)`. also creates getters. default values for key and value types apply.
    * mappings of mappings: `mapping(uint => mapping(uint => bool))`
* Structs for more than [k,v] pairs - you can store more information in an "account" e.g. timestamp, etc.
    * do only the most necessary functions on the blockchain and leave everythign else offchain
    * `mapping(address => MyStruct) someMapping` allows `someMapping[ADDRESS].attribute`
    * **local variables which are complex** require a `memory` declaration e.g. `Payment memory payment` creates a local variable `payment` of the type `Payment` struct
    * cannot return Structs on solidity, have to manuall unpack attributes
    * Struct attributes should be preceeded with `_` e.g. `struct Foo { uint _id }`
* Re-Entrancy / Recursive calling: **Always interact with _external addresses LAST_**e.g. `.transfer` should be the last instruction in a function.
    - [x] [Checks Effects Interactions](https://fravoll.github.io/solidity-patterns/checks_effects_interactions.html)
        * reduce attack surface for malicious contracts hijacking control flow
        * EVM is not concurreny, when calling an external add, the contract is also transferring control flow to the external entity, and _can now control the flow and execute inherent code_
            * notice that `.tranfer` is invoked by the `_to` address, not `this`.
        * **re-entrancy**: external contract is re-entering initial contract **before the first function call is finished**
            * repeated invoke functions that should only be executed once. see the DAO hack
        * Use CEI pattern when:
            1. it is unavoidable to hand over control to external entity
            2. guard functions against re-entrancy
        * Principle: Update all state variables **before external interaction**- optimistic accounting: all effects are written down before taking place.
            1. **checks**: does the user have sufficient balance
            2. **effects**: apply changes to state variable (balance mapping)
            3. **interactions**: call `.transfer` to `msg.sender`
        * without CEI: if I comes before E, and instead of `transfer()`, a lowlevel opcode `call.value()` is used - reentrancy is possible.
            * control flow is passed to the external contract, and it can call `withdraw()` again before first invocation is finished, without being intercepted by `withdraw()` check -- since state variable is not updated yet at the time of `call()`
* Assert to check invariants - states in which vars, or contracts should never reach e.g. out of bounds
    * e.g. `uint64` types only allow max value of 2^64. sending more ETH into a `uint64` balance will cause sent funds to disappear because the max values will rollover.
    * use `assert` to **throw exceptions** e.g. when casting types, verifying/confirming state changes
* `require` should be used for both:
    * validation checks
    * confirmation of change, esp for interactions with other contracts or 3rd party
* Fallback functions: anonymous functions in Solidity 0.6, or separated to `receive()` (receives money) and `fallback()` (smart contract interactions without ETH)
    * use fallback functions e.g. `receive()` to alias a deposit function etc.
    * fallbacks will also print the final function being called

* Reading values is free. Using `view` (reads state variables) and `pure` (does not read state variables)
    * `pure` functions can be used for type manipulations, calculations, interface functions etc. since they don't need to access a state variable.

* `calldata` is where data from external calls to functions is stored.
* `external` vs `public`: in public functions, arguments is copied to memory where as external functions read directly from `calldata` - reducing memory allocated to function calls.
    * `public` - accessed by all
    * `external` - cannot be accessed internally
    * `internal`- only by this contract _and other contracts deriving it_
    * `private` - only by this contract

* `_;` statements in modifiers are used to return the call control to the invoking function

* `import "https://..."` to import remote smart contracts
* contracts can be inherited from each oether. Contract inherits other Contract. e.g. `Allowance is Ownable, SharedWallet is Allowance`

* use `event`s extensively

* `enum` types: `enum myEnum{Foo, Bar, Baz}`

* how to call methods in another contract (that is not inherited):

    ```solidity
        address(OtherContract).call{ value: _TXN message value_ }(abi.ecodeWithSignature("THE_METHOD_TO_CALL(argument)", arg1, arg2 etc...));
    ```

* `virtual`: overwriting functions. function can change its behavior in derived classes.

* [`SafeMath`](https://github.com/ConsenSysMesh/openzeppelin-solidity/blob/master/contracts/math/SafeMath.sol) used to be relevant before solidity 0.8 due to overflows. with 0.8.0 `SafeMath` is not needed anymore:
    * `.add(), .mul()` can now be written as `x+y, x*y`
    * prev, using SafeMath declaration `using SafeMath for uint`

* override functions using `override` modifier
- [ ] [Secure Ether Transfer](https://fravoll.github.io/solidity-patterns/secure_ether_transfer.html):
    * secures ETH transfer from between contracts:
    * in earlier vesions of solidity, transfer are done using : `address.send(amount)` but send does not propagate errors, and gas must be manually specified.
    * a new transfer fucntion for Solidity 0.4.13 `transfer(amount)` was added
    * use SET when:
        * transfer ETH from contract to another address
        * not sure which method of transfer `call`, `send`, `transfer` is suitable
        * guard against `re-entrancy` attacks
- [ ] Solidity [Security Considerations](https://docs.soliditylang.org/en/develop/security-considerations.html?highlight=check%20effects#pitfalls)

- [ ] Consensys: Smart Contract [Known Attacks](https://consensys.github.io/smart-contract-best-practices/known_attacks/)

- [ ] [guylando](https://github.com/guylando/KnowledgeLists/blob/master/EthereumSmartContracts.md): Smart Contract security recommendations


- [x] Solidity v0.8 breaking changes:
    * arithmetic ops reverts on underflow and overflow. escape with `unchecked {}`
    * remove need for `SafeMath` operations e.g. `mul()`, `add()`
    * exponention is right-associative: `a**b**c` = `a**(b**c)`
    * Failed asserts, division by zero and overflows now throw `revert` opcode and call `Panic(uint256)`.
    * byte array in storage accessed with incorrect length throws panic
    * constant vars used in intermediate experssions will be rounded, not using arbitrary precision
    * `byte` type is removed, change to `byte1`
    * explicit conversation from negative and non-neg literals larger than `uint160` to `address` are disallowed

- [x] [`delegatecall`](https://docs.soliditylang.org/en/v0.8.6/introduction-to-smart-contracts.html?highlight=delegatecall#delegatecall-callcode-and-libraries): variable of `call` but code at target address is executed in context of _this_ calling contract. `msg.sender`, `value` are not changed
    * dynamiclally load **code from different address** at runtime. storage, current address and balance are still referring to the calling contract.

## Smart Contracts* and Dev Resources

- [x] [Gnosis Safe Multisig](https://blog.gnosis.pm/announcing-the-gnosis-safe-multisig-launch-a5d4ab17bd01) - create multisig wallets
    * use by consensys, synthetix, ens, kuber, bal, yearn, sushi, aave, 1inch.
    * Gnosis Safe features: multisig, defi integration, privacy, NFT support, gasless signature, open source.
    - [x] [Multisig Launch](https://blog.gnosis.pm/announcing-the-gnosis-safe-multisig-launch-a5d4ab17bd01) details
    - [x] [Safe Apps](https://blog.gnosis.pm/introducing-gnosis-safe-apps-faef908f69c6) launch
        * Direct interaction with Ethereum apps direction from Safe Multisig UI. Nothing special, you can import dApps into the Safe Apps UI: _makes Safe Multisig a browser into the “internet of value”_
    * MultiSig wallets:
        * everyone can deposit funds, but only owners can execute txns from wallet
        * Add/remove/replace owners require a threshld of owners for confirmation.
        * hardware wallet integration
        * import/export external Ethereum V3 format accounts
        * txn simulation
        * offline signing
    * Gnosis testnet on [Rinkeby](https://rinkeby.gnosis-safe.io/app/)
    * Changing owners is a txn
    * Setting spending limits by asset-amount-beneficiary. Beneficiary is any contact listed in the address book. Allowed amount can be reset over a time period.
    * **Approving Vault transactions:** Safe transaction approvals requests for individual signatures, not txns. Safe owners can choose to only **sign for approval** without paying to **execute the transaction**. But 1 owner is required to actually _approve the txn_, and will have to pay for gas.
    * Incomplete transactiosn will show in queue as Need Confirmations. Confirmations can be rejected while pending.
- [x] Why do dApps/clients communicate over [RPC](https://ethereum.stackexchange.com/questions/85245/why-do-blockchain-networks-like-ethereum-utilize-json-rpc-calls-and-not-rest-api)? Client are invoking procedures between each other, instead of managing resources via HTTP. Separate proposal for Eth clients to [use GraphQL](https://eips.ethereum.org/EIPS/eip-1767)
- [x] Yearn Vesting [Escrow contract](https://github.com/banteg/yearn-vesting-escrow) based on CurveDAO and Aragon Voting App - vesting contracts
    * [VestingEscrowSimple](https://github.com/banteg/yearn-vesting-escrow/blob/master/contracts/VestingEscrowSimple.vy#50) - simple vesting for any ERC20 token on init only.
- [x] [Solidity by example](https://docs.soliditylang.org/en/develop/solidity-by-example.html) - Example contracts
- [x] [Gelato v1](https://medium.com/gelato-network/introducing-gelato-v2-the-most-reliable-way-to-automate-your-ethereum-smart-contracts-73cd0010599e): Bots for Automation in Ethereum
    * Automatic Chi minting: [repo](https://github.com/gelatodigital/gelato-chi)
    * DCA buying ETH from uniswap: [repo](https://github.com/gelatodigital/gelato-uniswap)
    * Users/Task Owners (**Providers**) deposit ETH to network of relay servers (**Executors**) to execute **Tasks**
    * **External Providers**: pay/deposit ETH on gelato to abstract from end-user experieience
    * **Self Providers**: end-users, must deposit ETH on gelato for future transactions.
    * `GelatorUserProxy`: proxy wallet. can be a Gnosis Safe or Maker DSProxy
    * Step 1: Provider creates a proxy contract that will be used to interface with Gelato network.
    * Step 2: Deposit ETH to Gelato Core, set Gelato Execution Network and whitelist provider's proxy: [code](https://github.com/gelatodigital/gelato-uniswap/blob/master/demo/Part-1_Gelato_User/step2-user-proxy-setup.js#L72)
    * Step 3: Create new `Action` with ABI, deposit ETH, op to call from Step 1 proxy
    * Step 4: create Gelato `Tasks` (Conditions + Actions). for DCA-ing ETH on uniswap:
        * Condition: every 2 minutes [contract](https://github.com/gelatodigital/gelato-uniswap/blob/master/contracts/gelato_conditions/ConditionTimeStateful.sol)
        * Action: Trade 1 DAI for WETH [contract](https://etherscan.io/address/0x7a250d5630b4cf539739df2c5dacb4c659f2488d#code)
    *  To complete requires 2 txn: approve Proxy to move DAI from wallet, then Submit task to GelatoCore contract.
    *  Task definition: [code](https://github.com/gelatodigital/gelato-uniswap/blob/master/demo/Part-1_Gelato_User/step3-submit-task-uniswap.js#L170)
    *  Submit task from User Proxy, to gelato network (via GelatoProvider): [[code](https://github.com/gelatodigital/gelato-uniswap/blob/master/demo/Part-1_Gelato_User/step3-submit-task-uniswap.js#L305)]
- [x] [Gelato v2](https://medium.com/gelato-network/introducing-gelato-v2-the-most-reliable-way-to-automate-your-ethereum-smart-contracts-73cd0010599e)
    * Service Standards - set of functions for specific sets of use cases, no longer one size fits all
    * Removes required proxy contracts to save gas costs
    * Off-chain logic to pre-compute data and save gas
    * No pre-deposits and multi-asset deposits
    * metatxn support: users signs offchain message to Gelato Service Relay, pulled by Executors
    * Bot coordination - allocate slots to different Executor operators to prevent front-running
    * on [EIP-2535 Diamond Standard](https://www.youtube.com/watch?v=ttv4ecXykfM)

- [x] Buidler - productivity/dev [tools](https://medium.com/nomic-labs-blog/how-to-get-started-with-buidler-68beb6b9bb04)
    * define custom task builders e.g. adhoc tasks, testing etc. custom scripts are stored in `buidler.config.js`

- useful web3 APIs:
    * `web3.utils.fromWei('100', 'ether');`: convert wei to eth
    * `Buffer.from('hello world').toString('hex');`: string to hex

- [x] using Remix IDE to execute low-level calldata e.g. to test fallback functions

- [x] truffle uses [mochajs](https://mochajs.org/api/mocha) for unit testing
    - [ ] [lazy variables](https://sergiy-stotskiy.medium.com/lazy-variables-with-mocha-js-d6063503104c) with mocha

- [x] [External function calls](https://docs.soliditylang.org/en/v0.8.6/control-structures.html#external-function-calls) over low-level calls
    - [ ] Calling functions of [other contracts](https://medium.com/@houzier.saurav/calling-functions-of-other-contracts-on-solidity-9c80eed05e0f)
    - [ ] [delegateCall](https://medium.com/coinmonks/delegatecall-calling-another-contract-function-in-solidity-b579f804178c)

- [x] ERC20 notes:
    * [\_mint](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/ERC20.sol#L250)
    * [\_burn](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/ERC20.sol#L273)
    * [\_approve](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/ERC20.sol#L273): where user approves owner contract to spend tokens with a max value.
    * [\_setupDecimals](https://docs.openzeppelin.com/contracts/3.x/api/token/erc20#ERC20-_setupDecimals-uint8-): sets # of decimals. if not a divisible token (e.g. have large mint value), makes sense to set to `0`.
    * `_setupDecimals` removed. needs to be overloaded
    * use `_method` for internal methods


- [ ] [function overloading](https://www.bitdegree.org/learn/best-code-editor/solidity-functions-example-12) - overwriting functions by having multiple definitions for the same name: but number of arguments must be different e.g. given `foo()`, overload with `foo(bool _stub)` so solidity will match functions based on definition.

- [x] [Crowdsale contracts](https://github.com/ConsenSysMesh/openzeppelin-solidity/blob/master/contracts/crowdsale/Crowdsale.sol) (deprecated?)
    * removed since OZ 2.5 due to complexity and decrease in usage. mostly used for ICO.
    * selling initial tokens for [fundraising](https://medium.com/crowdbotics/how-to-build-a-simple-capped-crowdsale-token-using-openzeppelin-library-part-1-2789ec642308). extend with condition: capped crowdsale, vesting etc.

- [x] [SafeERC20](https://docs.openzeppelin.com/contracts/4.x/api/token/erc20#SafeERC20): wrappers around base ERC20 operations that **throws on failure instead of just return false/null**
    * for transfers, approvals, increase and decrease allowance


- [x] [`using A for X`](https://docs.soliditylang.org/en/v0.8.6/contracts.html?highlight=using%20for#using-for): attach library `A` to any type `X`.
    * makes sense when you have functions `f`, `g` that doesn't belong to Contract/type `X`, but you want to be able to have `X`.`f()` in another contract `Y`.
    * functions in lib well receive the calling object as first parameter i.e. In `Y`, `X.f()` will automatically pass `Y`'s state instance of `X` as a first argument to `f()`.
    * Can be denoted as `using A for *` to attach for all types - but all functions are attached regardless of first parameter type
    * `using .. for ..` is only active within the curent contract and has no effect outside.
    * use this to **extend native types e.g. arrays, structs**

- [x] [[docs](https://docs.soliditylang.org/en/latest/contracts.html?highlight=abstract#abstract-contracts)] `abstract contract`: marking when at least one of the functions in this contract is not implemented. Contracts can be `abstract` even if _all_ functions are implemented. use for parent contracts in inheritance, and some functions are to be defined by the children contract.
    - [x] interfaces _cannot have any functions **implemented**, only declared with `external` i.e. to be overwritten_. Interfaces also cannot inherit from contracts, only from other interfaces.

* [Testing Child contracts](https://gist.github.com/czhc/d6d22835c0215018f43f747d12a78bc7) locally on truffle console using Web3js and ethers

### Standards and Design Patterns

- [ ] [Upgradable Contracts](https://ethereum-blockchain-developer.com/110-upgrade-smart-contracts/00-project/)
- [ ] [VomTom](https://www.youtube.com/watch?v=YpEm9Ki0qLE): Smart Contract Upgrades and Proxy Patterns
    1. Eternal Storage - separate storage from logic (address).
    2. Proxy Contract - keep user-facing address, and/or storage
    3. Diamond Standard
    4. Metamorphic Smart Contracts - uses [create2](https://docs.openzeppelin.com/cli/2.8/deploying-with-create2)
        * without CREATE2: contract address is **computed from deployed address and nonce**
        * with CREATE2: instruct EVM to reserve a contract address. You can then selfdestruct and redeploy new contracts to the same address

- [x] EIP 2535: [Diamond Standard](https://eips.ethereum.org/EIPS/eip-2535)
    * Smart contracts with no size limit (above 24KB) and is modular and gas-eficient
    * Contracts can be upgraded on the fly without redeploying - single address for unlimited contract functionality
    * Standardize contract interfaces and implementation details: code and data architecture
    * A diamond is a contract with external functions that are supplied by contracts called facets.
    * Facets are separate, independent contracts that can share internal functions, libraries and state variables.
- [x] Gelato Dev Meetup: [video](https://www.youtube.com/watch?v=ttv4ecXykfM)
    * Core component: **fallback functions** delegates functions from **facet** contracts.
    * Function-to-facet mapping (bytes => address) allow upgradeability without proxies, just changes ToFacet mapping.
    * Does not support solidity built-in _state variable layout_ : replaced with **Diamond Storage**, or storage contracts.
    * **DiamondCut** and **Loupe** trackes state changes and function-facet maps to introspect diamond
    * inter-facet function calls done as _internal functions_
    - [x] Diamond contract explorer: [louper.dev](https://louper.dev/) - tracks history of facet modifications
    - [x] ToB: how the Diamond standard [falls short](https://blog.trailofbits.com/2020/10/30/good-idea-bad-design-how-the-diamond-standard-falls-short/)
        * working upgradeability stndard should include: upgrade procedures, on-chain mitigitaions against function shadowing and collisions, list of associated risks, integration tests etc.
        * (1) Lookup table - delegatecalls to multiple contract implementation. used in Colony Network [Delegate Proxy](https://colony.io/dev/docs/colonynetwork/docs-upgrade-design) pattern
        * (2) Aribitrary storage pointer - assigns storage pointer to arb location.
        * Storage pointer risks - collisions are still possible
        * Function shadowing - functions in proxy that shadow functions in delegate. - use slither-check-upgradeability for checking shadowing
        * No-contract existence check
        * unnecessary vocabulary change
    - [ ] [Response](https://dev.to/mudgen/addressing-josselin-feist-s-concern-s-of-eip-2535-diamond-standard-me8)

- [ ] OpenZep: Using [`CREATE2`](https://docs.openzeppelin.com/cli/2.8/deploying-with-create2)
      * Predict/precompute the address that a contract will be deployed

- [ ] OpenZep: [Deploying and interacting](https://docs.openzeppelin.com/learn/deploying-and-interacting) with smart contracts
    * `npx hardhat node` - local blockchain. state of previous runs is not preserved.
    * install BOTH: `ethers` as a hardhat plugin [@nomiclabs/hardhat-ethers](https://www.npmjs.com/package/@nomiclabs/hardhat-ethers) plus the source `ethers` package.
    * `ethers.getContractFactory('MyContract')`
    * deploy script in [scripts/deploy.js](https://github.com/czhc/solidity-intro/tree/main/openzeppelin/scripts/deploy.js)
    * interact with contract in`npx hardhat console`: `ethers.getContractFactory`, `MyContract.attach('deployed address')`
    * return value of setters and getters returns the full txn data, including nonce, gas, block etc.
    * hardhat tests repo is `test/` - not plural.
    * using [test-helpers](https://docs.openzeppelin.com/test-helpers/0.5/) for elegant BN support, constants, `expectEvent`  and `expectRevert`.
        * test helpers is **web3 based**, so you need to truffle plugin + truffle-like syntax.
        * or use [waffle](https://hardhat.org/guides/waffle-testing.html) - compatible with ethers.js - [[docs](https://ethereum-waffle.readthedocs.io/en/latest/)]] [helpers](https://ethereum-waffle.readthedocs.io/en/latest/matchers.html#bignumbers)
    - [x] Using [hardhat-etherscan](https://hardhat.org/plugins/nomiclabs-hardhat-etherscan.html) to verify contracts
    - [x] ethers [utils](https://docs.ethers.io/v4/api-utils.html)
    - [ ] [Hardhat-upgrades](https://docs.openzeppelin.com/upgrades-plugins/1.x/hardhat-upgrades) for upgradeable contracts
        - [x] Using hardhat-upgrades with OpenZep [_contracts with constructors_](https://forum.openzeppelin.com/t/how-to-use-ownable-with-upgradeable-contract/3336/2)
        * use Initializable contract to modify constructor own Ownable.
        - [x] from OZ [docs](https://docs.openzeppelin.com/upgrades-plugins/1.x/writing-upgradeable#use-upgradeable-packages): OZ provides `Initializable` base contract
        * `constructor` vs `initializer`(custom function):
            * `constructor` is only called once on deploy. any `initializer` function (is a custom function) must be additionally secured to only allow call-once. - refactored into `Initializable`
            * `constructor` is auto-invoked by solidity. `initalize` must be manually called by child contracts
        * also change `Ownable` to `OwnableUpgradeSafe`
        * OZ upgradeable contracts use `Upgradeable` [suffix](https://docs.openzeppelin.com/contracts/4.x/upgradeable)
        * use [`_unchained()`](https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/master/contracts/access/OwnableUpgradeable.sol#L33) when deploying from proxy contract for `onlyOwner` functions
        * with hardhat upgrades: `upgradeProxy` to upgrade proxy. to test in console, `getContractFactory(V2)` and attach to proxy. note that you can still use V1 contract by attaching the proxy to the V1 contract factory / ABI.
        * upgraded proxies retain data/state.
        * OZ Upgrades Plugin deploys 3 contracts: (1) logic contract, (2) ProxyAdmin and (3) proxy / state / delegatecall
        * **WARNING**: when upgrading contracts, you **cannot change storage layout**. order of variables declared must be preserved. Add new `V2` variables _after_ V1 variables:
            ```solidity
                contract Box {
                    //...v1 variables
                    //...v2 variables
                }
            ```
        * after initial deploy, use `admin.transferProxyAdminOwnership` to a multisig address

- [ ] [Moloch](https://github.com/MolochVentures/moloch/tree/4e786db8a4aa3158287e0935dcbc7b1e43416e38/test#moloch-testing-guide) Testing Guide: testing best practices

- [ ] Colony Network [Delegate Proxy design pattern](https://colony.io/dev/docs/colonynetwork/docs-upgrade-design)
- [ ] [Gemini](https://www.youtube.com/watch?v=sPUBUcjdEzk) upgradeability implementation
- [ ] [Slither](https://github.com/crytic/slither/wiki/Upgradeability-Checks): Upgradeability checks


- [x] Eternal Storage: move setters/getters to separate contract (Storage), and only let Logic contract interact with Storage contract

- [x] EIP-897 [ERC DelegateProxy](https://eips.ethereum.org/EIPS/eip-897)
    * *ProxyStorage* - logic
    * *NotLostStorage* - storage
    - [x] first [base proxy](https://gist.github.com/Arachnid/4ca9da48d51e23e5cfe0f0e14dd6318f)
        * 1 base, `abstract` contract `Upgradeable`that is inherited by all upgradeable contracts.
            * `initialize() virtual`: to be used by Example
            * `replace()`: used by `Dispatch` - makes Example `initialize` to execute in `Upgradeable`
        * `Dispatch` - works a shim to dispatch/delegate call to target contract. storage and value is kept on dispatcher. when the target contract is updated, the new contract inherits data and value from the old contract, as it is stored in this `Dispatch`
            * `constructor` calls `Upgradeable` `replace()` to assign the first Example contract to self (Dispatch).
            * `initialize` function `throws()` or `assert(false)`. should never be used here.
            * `fallback`:  **important**: this part _executes the function of the Example contract_ but _stores its return value back inside the `Dispatcher`_.
            * because the `Dispatch` doesn't have any setter/getters, it will use `fallback` to `delegatecall` to the current target address.
        * `Example` - the logic contract that implements the setters, getters etc. Logic contracts will be upgraded etc without affecting data stored in Dispatcher.
        * in remix, it will look like a contract using the `Dispatcher` address but has the functions of the `Example` / upgradable contract.
        * when upgrading the logic - deploy `Example2`, and call the `Dispatcher` to `replace` its target address.
    * **Storage Collisions**: without an inheritance, `Dispatch` and `Example` will share the same value due to having the same storage slot.

- [x] [EIP-1822](https://eips.ethereum.org/EIPS/eip-1822): Universal Upgradeable Proxy Standard UUPS (recommended over transparent proxy)
    * Proxy Contract `fallback` - stores address of Logic Contracts at a predefined, specific storage position instead of leaving it to the compiler: using `sload(keccak256(EXAMPLE))`, `sstore(keccak256, address)`
    * completely avoid variable collision between Proxy and Logic contracts.
    * `Proxy` contract input: logic contract address + logic contract's `constructor` keccak256 --> sstore and delegate logic contract to call its own constructor
    - [x] (2018). OpenZep: Upgradeability using [Unstructured Storage](https://blog.openzeppelin.com/upgradeability-using-unstructured-storage/)
        * using fixed storage slots for writing/reading thru inline assembly
        * stores pointers in proxy contract for proxy owner and proxy implmentation for reserved `keccak256(string)`
    * leads to ERC1967 below

- [x] [EIP-1967](https://ethereum-blockchain-developer.com/110-upgrade-smart-contracts/09-eip-1967/): Standard Proxy Storage slots
    * standardize how proxies store address of logic contracts to be easily understood by block explorers and auditors.
    * this specific storage slot `0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc` is reserved for logic contracts
    * already implemented by open zepellin `UpgradeabilityProxy`
    - [x] Open Zep [Proxy](https://docs.openzeppelin.com/contracts/4.x/api/proxy#Proxy)
        * fixed storage slot: [L24](https://github.com/OpenZeppelin/openzeppelin-sdk/blob/dc9e4edf1169eb8bd675961c9d821d1a712a70df/packages/lib/contracts/upgradeability/BaseUpgradeabilityProxy.sol#L24)
        * [upgradeTo](https://docs.openzeppelin.com/contracts/3.x/api/proxy#TransparentUpgradeableProxy-upgradeTo-address-) for upgrading logic contracts.
    * etherscan provides a _is this a proxy?_ to check verification status of the proxied contract.

- [x] [Transparent vs UUPS proxies](https://docs.openzeppelin.com/contracts/4.x/api/proxy#transparent-vs-uups)
    * in UUPS or [ERC1967](https://docs.openzeppelin.com/contracts/4.x/api/proxy#ERC1967Proxy), upgrades is handled by implementation and can be removed.
        * proxy itself is not upgradeable.
        * unless you use [UUPS-Upgradeable](https://docs.openzeppelin.com/contracts/4.x/api/proxy#UUPSUpgradeable)

    * in [Transparent](https://docs.openzeppelin.com/contracts/4.x/api/proxy#TransparentUpgradeableProxy) proxies, proxy itself handles upgrade and admin logic. Transparent-upgradeable proxies is more expensive to deploy.

    * both patterns use the same storage slot. **AVOID using together**

- [ ] [Implementing upgrades using hardhat plugins](https://docs.openzeppelin.com/upgrades-plugins/1.x/)
    * use this if you don't need low-level controls

- Maker's DSProxy
    - [ ] [Short intro DSProxy](https://medium.com/defi-saver/a-short-introduction-to-makers-dsproxy-and-why-we-l-it-c88932595be)
    - [ ] [DSProxy docs](https://docs.makerdao.com/build/dai.js/advanced-configuration/using-ds-proxy)
- DefiSaver [Smart Savings](https://help.defisaver.com/smart-savings/what-is-the-user-wallet)
- Oasis [Direct Proxy](https://oasisdex.com/docs/guides/use-proxy)

- [x] [ToB](https://blog.trailofbits.com/2018/10/29/how-contract-migration-works/): how contract migration works (Disaster Recovery)
    1. Data recovery - read data from the block right before the incident or before attacker txns
        * pause contract and get public variables
        * get private variables from events or compute variable memory offset
        * use [Ethereum ETL](https://github.com/blockchain-etl/ethereum-etl) for extracting data to offchain
    2. Data restore
        * use constructor for simple variables
        * add initialization state to contract: deploy contract with initial state -> migrate balances -> deploy to  production
        * use [ERC20Pausable](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/03dfb2965c6a607e216b110910f9fce1c43d8c94/contracts/token/ERC20/ERC20Pausable.sol) to manually disable and reenable after dta recovery.
    3. Update exchanges with new token contracts
    * compare this to upgradeable contracts

- [x] (2018). [ToB](https://blog.trailofbits.com/2018/09/05/contract-upgrade-anti-patterns/): Contract upgrade anti-patterns
    * patterns: (1) data separate of logic and data, (2) delegatecall-based proxies: data contract calls logic with `delegatecall`
    * patterns:
        1. data separation: user -> logic -> data
            * all setters must have `onlyOwner`
            * suitable for erc20 token contracts
            * new persistent variables are introduced in new data contracts, and will require additional logic calls and authorization
            * data contract can implement `bytes42 => type` for each base variable type
            * to migrate: transfer ownership of data to a new logic contract, and disable old logic contract with `Pausable`/burn, or write for forwarding calls to new contract
            * in addition, can use proxy in-front of logic contracts:
            * user -> proxy -> (logic contracts) -> data contract
            - [ ] [rocketpool](https://medium.com/rocket-pool/upgradable-solidity-contract-design-54789205276d) implementation
            - [ ] [cardstack](https://medium.com/cardstack/upgradable-contracts-in-solidity-d5af87f0f913) implementation
        2. delegatecall proxy: user -> proxy(data) -> logic
            * `delegatecall`: this contract (proxy) holds caller context and storage --> pulls code/logic from another contract.
            * **order of storage variables** in a `delegatecall` pattern matters and can result in memory corruption _(Storage Collision)_.
            * **SOLUTION? using Inheritance (a super contract) on both Proxy and Logic** to declare variables and ensure proxy and logic has the **same memory layout**.
        3. using [**Unstructured Storage**](https://github.com/OpenZeppelin/openzeppelin-labs/tree/ff479995ed90c4dbb5e32294fa95b16a22bb99c8/upgradeability_using_unstructured_storage) [[blog](https://blog.openzeppelin.com/upgradeability-using-unstructured-storage/)]
            * overcomes memory layout requirement, but requires low-level memory handling. - not analyzable with static scanning
            * due to complexity, using this only for critical state variables that affect upgradability of contract
    * use the simplest upgradeability pattern possible. most cases should avoid low-lvel calls.

* _WARNING:_ low-level calls, `delegatecall` and `callcode` will return _success if the called account does not exist_ as part of EVM design. **Always check first (using `extcodesize`)** and do not modify own state before confirming
    * callers **should always check** `returndatasize` to ensure the call is truly successful.

- [x] [@prestwitch](https://twitter.com/_prestwich/status/1410686936621084672): what happens in a call to another contract?
    * pre-call checks:
        1. solidity uses EXTCODE to check that the address contains code. or reverts with no message!
        2. solidity ABI-encodes args
        3. solidity adds function selector (4byte method ID) to arguments
        4. call is sent and returned
    * post-call checks:
        1. soliidty checks call succeeded, or copies revert error to memory
        2. solidity ABI-decodes response and checks return types (reverts when error) may contain extra returndata.

### Peer-to-peer payments

- [x] [Superfluid](https://medium.com/superfluid-blog/superfluid-streams-5cc5141dd8a7) - money streaming
    * streaming funds from wallet to wallet, continuously until manual stop or until balance is 0
    * set flow rate of tokens from hourly - yearly, but pro-rated per second. Streams do not cost gas, only when open/close/edit
    * Source amount is not locked and available in wallet.
    * Possible using wrapped ERC20s - SuperTokens
    - [x] Constant [FLow Agreement](https://docs.superfluid.finance/superfluid/docs/constant-flow-agreement)
    * deployed on Polygon and xDAI
    * [Partnership](https://medium.com/ethereum-push-notification-service/programmable-money-2-0-meets-epns-4a2f52dccb32) with EPNS

- [x] Superfluid: Dawn of [Programmable Cashflows](https://medium.com/superfluid-blog/the-dawn-of-programmable-cashflows-2d50edae05cb)
    * transfer any token or digital asset on-chain using predefined rules ("agreements")
    * transfer X amount per T period, but value is paid per-second, realtime without needing gas or txns.
    * Agreements are (1) Money streaming or (2) Rewards distributions
    * Register smart conracts as _SuperApps_, reacts to stream events.
    - [x] [UI](https://app.superfluid.finance/)
        * Sender deposits asset, create stream for asset with receiver, amount and interval. No swapping in streams. Sender can send multiple streams/assets to same receiver.
        * realtime accrual in receiver dashboard. **receiver can cancel a stream**. receiver can share link to stream.
        * Currencies in SF are wrapped as [Super Tokens](https://docs.superfluid.finance/superfluid/protocol-tutorials/primitives#2-super-tokens) (ERC777 - tokens that react to events using callbacks)
        * Can't seem to set an End time - only until the wallet balance ends. Use Gelato instead


- [ ] [MetaTxn](https://metatx.io/) for recurring payments, powers Gitcoin Grants - from griffith [token-subscriptions](https://github.com/austintgriffith/token-subscription)
    * MetaTxns are txns that are signed and delegated to a 3rd party to put on-chain.
    - [ ] [overview - youtube](https://www.youtube.com/watch?v=6r3SqCcEVU4)
    - [x] A.Griffith: Ethereum [Meta Transactions](https://medium.com/@austin_48503/ethereum-meta-transactions-90ccf0859e84)
        * First-time gas to be paid by _3rd party (desktop miners)_.
        * User signatures are stored in browser to remove initial barrier of wallet adoption.
        * MetaTxs are similar to Eth txns, but with:
            *  Data: encoded info detailing list of actions including hash of function name to call and args
            *  **Reward:** to be paid to desktop miners in ETH or tokens, paid from an identity proxy contract, not directly from user account
            *  Requirements: extended requirements e.g. time/chronological check.
        *  MetaTxs are sent to a secondary network, and the network validates and interfaces with the blockchain. A proxy contract receives the metatx processes the instructions, pays the miner and execute metatx commands.
    *  Identity Proxy Contract: onchain proxy contract to receive metatx from 3rd party and call metatxn instructions.
    - [ ] [ZK Labs](https://zklabs.io/audits/tokensub.html) audit

- [x] [ERC948](https://gitcoin.co/blog/technical-deep-dive-architecture-choices-for-subscriptions-on-the-blockchain-erc948/): Architecture Choices for Subscriptions on the Blockchain
    * Arch 1: User-driven txns completely on-chain between pariticipants. payer/subscriber creates subscription with payee/provider and payment interval, approves transferFrom() contract. Payee/provider stores events and executes subscription.
    * Arch 2: Limited Delegation Txns. Uses a _Processor_ with approval to process txn on behalf of provider. Processors are any form of delegated 3rd party : single, multiSig or address whitelist.
    * Arch 3: Meta Txns: signed message of intent from user, delgated to processor, reused recurringly.
        * payer/subscriber creates subscription, approve subscription contract, and signature. signed message is given to payee/provider.
        * payee/provider stores signed message and calls executeSubscription at given intervals, or pass the payer signature  to a _processor_ to execute on payee's behalf
        * basically double-delegation using signed messages.
        * use for any type of recurring action and N processors without explicit approval
- [x] [Groundhog Payments](https://groundhog.network/) using [EIP-1337]()-- looks inactive.


## How To DeFi

- [x] Sanagaki: [Liquidity Provision in UniV3](https://www.saganaki.xyz/liquidity-provision.html)
   - [ ] [src: Strategic Liquidity Provision in UniV3](https://arxiv.org/abs/2106.12033)
   *  **reset strategy**: moving liquidity price range
   *  moves such that a reset is warranted; where do you provide liquidity next, and how should you distribute it within that range?
   *  evaluation using constant absolute risk aversion utility function (CARA) utility function: risk aversion parameter _a_. 
      * Exponential utility, `u(x): 1 - exp(-x/R)` where x: real world value, u(x): preceived value.
      * exponential utility is used to model risk aversion. R (risk tolerance) determines concavity of utility function.  
      * In holding risk+risk-free asset, optimal holding of risk asset is independent of initial wealth. any additional wealth is allocated to additional holdings of risk-free asset.   
   * decision rules:
      *  #1 uniform strategy: uniform liquidty distribution
      *  #2 proportional strategy: distribution proportional to propability distribution over a fixed range % of next period price
      *  #3 optimal strategy: fix risk aversion parameter _a_ in CARA
   *  assumptions: profits are propotional to gas cost. fees earned is multiple _k_ of liqudity _l_ in active range. 
   *  resuts: Providing liquidity in proportion to next period probability **(strat #2) is near-optimal**. only in extreme risk-aversion _R_ is uniform distribution (Strat #1) optimal. 
      * for most reasonable risk aversion values, a wide _tau_ (infrequently moving strategy) maximizes utility.  // _tau_ is the width of liquidity range. in this papaer, fixed at _tau_=50, optimize of _a_.


- [x] Saganaki: [IL in DEXes](https://www.saganaki.xyz/imp-loss-post.html)
   * scope: UniV2 for stablecoin and low MC token pools between May2020-Jan2021.
   * Stable Pools: est 4% returns, or compounded 16.98% for min risk. 
   * Normal ETH-based paits: price fluctuations ~5%. in 4mo of LPs, returns can be -ve. avg daily returns -.75% to .75%
   * Exotic ETH-based pairs: IL up to -70% over 4 mos, not compensated by fees. 
   * Quantifying risk-return tradeoff using Value-at-Risk (VaR) and Conditional VaR @ 5%. 
      * STable pool have positive CVar, better than normal pool risk-return profiles.  
      * exotic pools are extremely volatilte with low carry (fees) which cannot compensate IL. i.e. exotic pools have high APR but may have higher IL. Farmed tokens must significantly compensate for this. 

- [x] [Baller](https://baller.netlify.app/): Impermanent loss in Balancer Pools