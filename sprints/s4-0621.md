# Sprint 3 - 06/14

## Ethereum

- [x] EthCatHerders: [London Upgrade Overview](https://medium.com/ethereum-cat-herders/london-upgrade-overview-8eccb0041b41)
    * EIP 1559: introduces _base fee_ to track network gas price based on demand for blockspace to simplify gas price estimations for UX
    * EIP 1559: also introduces new txn type: set _max fee payable_ and _max fee to miner_, with balance refunded
    * EIP2918: Adds opcode `BASEFEE` for 1559
    * EIP3529: Reduces gas refunds for `SSTORE` and `SELFDESTRUCT`. Gas refunds contribute to variance in block execution, and this reduces block size variance coming from 1559.
    * EIP3541: starts reserving prefix bytes `0xEF` for future 3540 semantics.
    * EIP3554: delays difficulty bomb to Dec 1 2021.

## L2, Sidechains and Scaling Solutions

- [x] [Tracer](https://tracer.finance/radar/arbitrum-in-under-10/): Arbitrum in under 10 minutes
    * Architecture
        * Component of Arbitrum in L1 is the **EthBridge** - referees the Arbitrum Rollup
        * Inbox/outbox accepts txns from users, L1 contracts, full nodes
        * AVM is function of EthBridge, is L1-L2 gateway to perform comutations
        * ArbOS runs on AVM, handles smart contract execution completely on L2 similar to EVM contracts on EVM.
    * Rollup
        * Message ordering in inbox determines result of txn
        * Confirming resuts on txn
        * **only 1 validator needed to force correction**
        * block proposal shave a deadline for confirmation
        * validator disagreeing with the block will propose own correction block for rewards after fraud proofs.
    * Staking:
        * Permissionless staking: stake on any block
        * Stacking is locked until the block is confirmed
        * block confirmation includes every block between _most recent unconfirmed block until your current staked block_
        * dynamic staking amount - includes base + (temporary) multiplied exponential factor during network attacks
    * Challenge:
        * Challenges is an interactive, multiround dissection on L2 and proof on L1
        * proof/defending a challenge is to execute N instructions on the preceding block to show the resulting state is equal to proposed block stake
        * N instructions are divided in equal sizes wrt. Arb gas
        * Identiy subsegment where defender and contender disagrees - **this subsegment's instruction is sent to L1 to execute and decide on winner**
        * loser has stake slashed and remainder of stake is awarded to the winner.
        * other validators are ab;e to determine result of dispute before dispute is final to create soft forks, and rollups can be submitted.
    * Validators:
        * Active: propose new blocks to add to chain. only 1 honest active validator is required per chain
        * Defensive: watches rollup and acts on dishonest behavior by proposing a correct block or stake on correct blocks
        * Watch tower: watches and alerts defensive validators to propose corrections
    * Full nodes:
        * does not require knowledge of rollup protocols
        * serves as txn aggregator and compressor to reduce gas costs
    * Sequencer Mode:
        * optional component - full node with additional privilege of txn ordering
        * instnaely guarantee result of txn - because **inbox txn order changes output result**
        * with a sequencer, the inbox is split into two: with and without sequencers.
        * sequencer can specify block # and timestamp when sending messages to inbox
        * # of backdate blocks is equals # of blocks needed for Ethereum finality.
        * with sequencers, txns will achieve finality x blocks faster
        * malicious sequencers can censor user txns by forcing them into regular inbox and frontrunning them. **Choice of sequencer operators matters**
    * ArbGas / Fees
        * provide predictable measure of time to validate result of computation
        * can be used as a block validity check to ensure the net gas consumed by disputed block is the same




## Defi Security

- [ ] OpenZeppelin [ReEntrancy Guard](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/security/ReentrancyGuard.sol)

### Pause Controls in Smart Contracts

- [x] Rex Hygate: [Pause Control](https://rex2.medium.com/pause-control-and-iron-finance-9b2d2e70f2a9) and Iron Finance
    * DefiSafety to include **transparency of pause controls** as part of reviews
    * All protocols should explain their pause capability - in terms of scope of pause, trigger/controls (e.g. multisig), breaksafe decision and testing procedures.
    * Pause capabilities to be _fire drilled_.
- [x] OpenZeppelin [ERC20Pausable](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/extensions/ERC20Pausable.sol) standard
    - [x] How to make a [Pausable ERC20](https://medium.com/coinmonks/how-to-make-a-pausable-erc20-token-9fb1ab5dc877)
    * `Paused` tokens are _only transferrable by the token contract owner_. The token needs to be `Ownable` first to assign an owner.
    * Pausing is used to stop all txns related to this token including swaps on DEXs.
    * `nonPausable` is irreversible - after this even the token owner is not able to pause.
- [x] Badger: [Early Timelock Withdraw exploit](https://medium.com/badgerdao/sgt-early-timelock-withdraw-post-mortem-f4ac0d79ee36) from SGT incident
    * Timelock contracts e.g. [Badger](https://github.com/Badger-Finance/badger-system/blob/master/contracts/badger-timelock/SmartTimelock.sol), [Compound](https://github.com/compound-finance/compound-protocol/blob/master/contracts/Timelock.sol) are used to implement set time delays before make an action accessible by the user. This can be used for vesting [[Badger Vesting](https://github.com/Badger-Finance/badger-system/blob/master/contracts/badger-timelock/SmartVesting.sol) - uses additional `onlyGovernor` multisig] etc.
    * Badger `SmartTimelock``call`: allows attacker to grant approval to another contract to pull funds.

## Smart Contracts* and Dev Resources

- [x] [Gnosis Safe Multisig](https://blog.gnosis.pm/announcing-the-gnosis-safe-multisig-launch-a5d4ab17bd01) - create multisig wallets
    * use by consensys, synthetix, ens, kuber, bal, yearn, sushi, aave, 1inch.
    * Gnosis Safe features: multisig, defi integration, privacy, NFT support, gasless signature, open source.
    - [x] [Multisig Launch](https://blog.gnosis.pm/announcing-the-gnosis-safe-multisig-launch-a5d4ab17bd01) details
    - [x] [Safe Apps](https://blog.gnosis.pm/introducing-gnosis-safe-apps-faef908f69c6) launch
        * Direct interaction with Ethereum apps direction from Safe Multisig UI. Nothing special, you can import dApps into the Safe Apps UI: _makes Safe Multisig a browser into the “internet of value”_
    * MultiSig wallets:
        * everyone can deposit funds, but only owners can execute txns from wallet
        * Add/remove/replace owners require a threshld of owners for confirmation.
        * hardware wallet integration
        * import/export external Ethereum V3 format accounts
        * txn simulation
        * offline signing
    * Gnosis testnet on [Rinkeby](https://rinkeby.gnosis-safe.io/app/)
    * Changing owners is a txn
    * Setting spending limits by asset-amount-beneficiary. Beneficiary is any contact listed in the address book. Allowed amount can be reset over a time period.
    * **Approving Vault transactions:** Safe transaction approvals requests for individual signatures, not txns. Safe owners can choose to only **sign for approval** without paying to **execute the transaction**. But 1 owner is required to actually _approve the txn_, and will have to pay for gas.
    * Incomplete transactiosn will show in queue as Need Confirmations. Confirmations can be rejected while pending.
- [x] Why do dApps/clients communicate over [RPC](https://ethereum.stackexchange.com/questions/85245/why-do-blockchain-networks-like-ethereum-utilize-json-rpc-calls-and-not-rest-api)? Client are invoking procedures between each other, instead of managing resources via HTTP. Separate proposal for Eth clients to [use GraphQL](https://eips.ethereum.org/EIPS/eip-1767)
- [x] Yearn Vesting [Escrow contract](https://github.com/banteg/yearn-vesting-escrow) based on CurveDAO and Aragon Voting App - vesting contracts
    * [VestingEscrowSimple](https://github.com/banteg/yearn-vesting-escrow/blob/master/contracts/VestingEscrowSimple.vy#50) - simple vesting for any ERC20 token on init only.
- [x] [Solidity by example](https://docs.soliditylang.org/en/develop/solidity-by-example.html) - Example contracts
- [x] [Gelato v1](https://medium.com/gelato-network/introducing-gelato-v2-the-most-reliable-way-to-automate-your-ethereum-smart-contracts-73cd0010599e): Bots for Automation in Ethereum
    * Automatic Chi minting: [repo](https://github.com/gelatodigital/gelato-chi)
    * DCA buying ETH from uniswap: [repo](https://github.com/gelatodigital/gelato-uniswap)
    * Users/Task Owners (**Providers**) deposit ETH to network of relay servers (**Executors**) to execute **Tasks**
    * **External Providers**: pay/deposit ETH on gelato to abstract from end-user experieience
    * **Self Providers**: end-users, must deposit ETH on gelato for future transactions.
    * `GelatorUserProxy`: proxy wallet. can be a Gnosis Safe or Maker DSProxy
    * Step 1: Provider creates a proxy contract that will be used to interface with Gelato network.
    * Step 2: Deposit ETH to Gelato Core, set Gelato Execution Network and whitelist provider's proxy: [code](https://github.com/gelatodigital/gelato-uniswap/blob/master/demo/Part-1_Gelato_User/step2-user-proxy-setup.js#L72)
    * Step 3: Create new `Action` with ABI, deposit ETH, op to call from Step 1 proxy
    * Step 4: create Gelato `Tasks` (Conditions + Actions). for DCA-ing ETH on uniswap:
        * Condition: every 2 minutes [contract](https://github.com/gelatodigital/gelato-uniswap/blob/master/contracts/gelato_conditions/ConditionTimeStateful.sol)
        * Action: Trade 1 DAI for WETH [contract](https://etherscan.io/address/0x7a250d5630b4cf539739df2c5dacb4c659f2488d#code)
    *  To complete requires 2 txn: approve Proxy to move DAI from wallet, then Submit task to GelatoCore contract.
    *  Task definition: [code](https://github.com/gelatodigital/gelato-uniswap/blob/master/demo/Part-1_Gelato_User/step3-submit-task-uniswap.js#L170)
    *  Submit task from User Proxy, to gelato network (via GelatoProvider): [[code](https://github.com/gelatodigital/gelato-uniswap/blob/master/demo/Part-1_Gelato_User/step3-submit-task-uniswap.js#L305)]
- [x] [Gelato v2](https://medium.com/gelato-network/introducing-gelato-v2-the-most-reliable-way-to-automate-your-ethereum-smart-contracts-73cd0010599e)
    * Service Standards - set of functions for specific sets of use cases, no longer one size fits all
    * Removes required proxy contracts to save gas costs
    * Off-chain logic to pre-compute data and save gas
    * No pre-deposits and multi-asset deposits
    * metatxn support: users signs offchain message to Gelato Service Relay, pulled by Executors
    * Bot coordination - allocate slots to different Executor operators to prevent front-running
    * on [EIP-2535 Diamond Standard](https://www.youtube.com/watch?v=ttv4ecXykfM)

- [x] Buidler - productivity/dev [tools](https://medium.com/nomic-labs-blog/how-to-get-started-with-buidler-68beb6b9bb04)
    * define custom task builders e.g. adhoc tasks, testing etc. custom scripts are stored in `buidler.config.js`

### Standards and Design Patterns
- [ ] [Upgradable Contracts](https://ethereum-blockchain-developer.com/110-upgrade-smart-contracts/00-project/)
    *
- [x] EIP 2535: [Diamond Standard](https://eips.ethereum.org/EIPS/eip-2535)
    * Smart contracts with no size limit (above 24KB) and is modular and gas-eficient
    * Contracts can be upgraded on the fly without redeploying - single address for unlimited contract functionality
    * Standardize contract interfaces and implementation details: code and data architecture
    * A diamond is a contract with external functions that are supplied by contracts called facets.
    * Facets are separate, independent contracts that can share internal functions, libraries and state variables.
- [x] Gelato Dev Meetup: [video](https://www.youtube.com/watch?v=ttv4ecXykfM)
    * Core component: **fallback functions** delegates functions from **facet** contracts.
    * Function-to-facet mapping (bytes => address) allow upgradeability without proxies, just changes ToFacet mapping.
    * Does not support solidity built-in _state variable layout_ : replaced with **Diamond Storage**, or storage contracts.
    * **DiamondCut** and **Loupe** trackes state changes and function-facet maps to introspect diamond
    * inter-facet function calls done as _internal functions_
    - [x] Diamond contract explorer: [louper.dev](https://louper.dev/) - tracks history of facet modifications
    - [x] ToB: how the Diamond standard [falls short](https://blog.trailofbits.com/2020/10/30/good-idea-bad-design-how-the-diamond-standard-falls-short/)
        * working upgradeability stndard should include: upgrade procedures, on-chain mitigitaions against function shadowing and collisions, list of associated risks, integration tests etc.
        * (1) Lookup table - delegatecalls to multiple contract implementation. used in Colony Network [Delegate Proxy](https://colony.io/dev/docs/colonynetwork/docs-upgrade-design) pattern
        * (2) Aribitrary storage pointer - assigns storage pointer to arb location.
        * Storage pointer risks - collisions are still possible
        * Function shadowing - functions in proxy that shadow functions in delegate. - use slither-check-upgradeability for checking shadowing
        * No-contract existence check
        * unnecessary vocabulary change
    - [ ] [Response](https://dev.to/mudgen/addressing-josselin-feist-s-concern-s-of-eip-2535-diamond-standard-me8)

- [ ] OpenZep: [Deploying and interacting](https://docs.openzeppelin.com/learn/deploying-and-interacting) with smart contracts
- [ ] ToB: How [contract migration](https://blog.trailofbits.com/2018/10/29/how-contract-migration-works/) works
- [ ] ToB: Contract upgrade [anti-patterns](https://blog.trailofbits.com/2018/09/05/contract-upgrade-anti-patterns/)
- [ ] Colony Network [Delegate Proxy design pattern](https://colony.io/dev/docs/colonynetwork/docs-upgrade-design)
- [ ] OpenZep: Upgradeability using [Unstructured Storage](https://github.com/OpenZeppelin/openzeppelin-labs/tree/ff479995ed90c4dbb5e32294fa95b16a22bb99c8/upgradeability_using_unstructured_storage)
- [ ] [Gemini](https://www.youtube.com/watch?v=sPUBUcjdEzk) upgradeability implementation
- [ ] [Slither](https://github.com/crytic/slither/wiki/Upgradeability-Checks): Upgradeability checks




### Proxy contracts, smart contract wallet, proxy wallets

- Maker's DSProxy
    - [ ] [Short intro DSProxy](https://medium.com/defi-saver/a-short-introduction-to-makers-dsproxy-and-why-we-l-it-c88932595be)
    - [ ] [DSProxy docs](https://docs.makerdao.com/build/dai.js/advanced-configuration/using-ds-proxy)
- DefiSaver [Smart Savings](https://help.defisaver.com/smart-savings/what-is-the-user-wallet)
- Oasis [Direct Proxy](https://oasisdex.com/docs/guides/use-proxy)


### Peer-to-peer payments

- [x] [Superfluid](https://medium.com/superfluid-blog/superfluid-streams-5cc5141dd8a7) - money streaming
    * streaming funds from wallet to wallet, continuously until manual stop or until balance is 0
    * set flow rate of tokens from hourly - yearly, but pro-rated per second. Streams do not cost gas, only when open/close/edit
    * Source amount is not locked and available in wallet.
    * Possible using wrapped ERC20s - SuperTokens
    - [x] Constant [FLow Agreement](https://docs.superfluid.finance/superfluid/docs/constant-flow-agreement)
    * deployed on Polygon and xDAI
    * [Partnership](https://medium.com/ethereum-push-notification-service/programmable-money-2-0-meets-epns-4a2f52dccb32) with EPNS

- [x] Superfluid: Dawn of [Programmable Cashflows](https://medium.com/superfluid-blog/the-dawn-of-programmable-cashflows-2d50edae05cb)
    * transfer any token or digital asset on-chain using predefined rules ("agreements")
    * transfer X amount per T period, but value is paid per-second, realtime without needing gas or txns.
    * Agreements are (1) Money streaming or (2) Rewards distributions
    * Register smart conracts as _SuperApps_, reacts to stream events.
    - [x] [UI](https://app.superfluid.finance/)
        * Sender deposits asset, create stream for asset with receiver, amount and interval. No swapping in streams. Sender can send multiple streams/assets to same receiver.
        * realtime accrual in receiver dashboard. **receiver can cancel a stream**. receiver can share link to stream.
        * Currencies in SF are wrapped as [Super Tokens](https://docs.superfluid.finance/superfluid/protocol-tutorials/primitives#2-super-tokens) (ERC777 - tokens that react to events using callbacks)
        * Can't seem to set an End time - only until the wallet balance ends. Use Gelato instead


- [ ] [MetaTxn](https://metatx.io/) for recurring payments, powers Gitcoin Grants - from griffith [token-subscriptions](https://github.com/austintgriffith/token-subscription)
    * MetaTxns are txns that are signed and delegated to a 3rd party to put on-chain.
    - [ ] [overview - youtube](https://www.youtube.com/watch?v=6r3SqCcEVU4)
    - [x] A.Griffith: Ethereum [Meta Transactions](https://medium.com/@austin_48503/ethereum-meta-transactions-90ccf0859e84)
        * First-time gas to be paid by _3rd party (desktop miners)_.
        * User signatures are stored in browser to remove initial barrier of wallet adoption.
        * MetaTxs are similar to Eth txns, but with:
            *  Data: encoded info detailing list of actions including hash of function name to call and args
            *  **Reward:** to be paid to desktop miners in ETH or tokens, paid from an identity proxy contract, not directly from user account
            *  Requirements: extended requirements e.g. time/chronological check.
        *  MetaTxs are sent to a secondary network, and the network validates and interfaces with the blockchain. A proxy contract receives the metatx processes the instructions, pays the miner and execute metatx commands.
    *  Identity Proxy Contract: onchain proxy contract to receive metatx from 3rd party and call metatxn instructions.
    - [ ] [ZK Labs](https://zklabs.io/audits/tokensub.html) audit

- [x] [ERC948](https://gitcoin.co/blog/technical-deep-dive-architecture-choices-for-subscriptions-on-the-blockchain-erc948/): Architecture Choices for Subscriptions on the Blockchain
    * Arch 1: User-driven txns completely on-chain between pariticipants. payer/subscriber creates subscription with payee/provider and payment interval, approves transferFrom() contract. Payee/provider stores events and executes subscription.
    * Arch 2: Limited Delegation Txns. Uses a _Processor_ with approval to process txn on behalf of provider. Processors are any form of delegated 3rd party : single, multiSig or address whitelist.
    * Arch 3: Meta Txns: signed message of intent from user, delgated to processor, reused recurringly.
        * payer/subscriber creates subscription, approve subscription contract, and signature. signed message is given to payee/provider.
        * payee/provider stores signed message and calls executeSubscription at given intervals, or pass the payer signature  to a _processor_ to execute on payee's behalf
        * basically double-delegation using signed messages.
        * use for any type of recurring action and N processors without explicit approval
- [x] [Groundhog Payments](https://groundhog.network/) using [EIP-1337]()-- looks inactive.
