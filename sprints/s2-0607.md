# Sprint 2 - 06/07

## Blockchain & Money. MIT 15.s12

Gary Gensler Goldman Sachs, US Treasury, MIT, SEC chairmain (2021)

- [x] [3.](https://www.youtube.com/watch?v=0UvVOMZqpEA) Blockchain Basics and Cryptography
    - [x] Cryptographic primitives: **(1) hash functions** for tamper resistance/integrity and (2) **digital signatures using asymm encryption** for  consent. 
    * Blockchain primitives - crytography and consensus
    * components of a block: 
        * Header: hash of previous block + timestamp + nonce + **merket root hash**
        * Own Hash Header
        * Txn list    
    * Solving the puzzle: having a **certain number of leading zeros**. It doesn't mean having the exact, identical hash. 
    
    >
    > The proof-of-work involves scanning for a value that when hashed, such as with SHA-256, the
hash begins with a number of zero bits.
    >
    > Avg work required is exponential to the number of zero bits required. W=e^n
    > Merkle tree is a binary tree of hashes.
    * Merkle tree: [hash of hashes of blocks](https://www.investopedia.com/terms/m/merkle-root-cryptocurrency.asp) for quick, mathematical verification
    * The [merkle root of a block](https://www.youtube.com/watch?v=V6gLY-1G4Mc), which is the hash of all hashes of all txns, contains info on all txns in the block.
    * One branch of a hash tree can be donwloaded and verified immediately even without the whole tree. Only small blocks of data need to be redownloaded and quickly checked. 
    * Any modified txn will change the value of the Merkle root of the block, and so the integrity of the block.
    * For an odd # of txns (2n-1) in a block, the last txn pair is duplicated for L1 hash to have 2 leafs
    * Digital signatures and asymmetric encryption: public + private key
    - Bitcoin addresses are not simply public keys to the private keys. 
    - **Bitcoin addresses = base58(public key x SHA256() x SHA256() + checksum)**


- [x] Cryptographic algorithms [overview](https://www.cryptomathic.com/news-events/blog/differences-between-hash-functions-symmetric-asymmetric-algorithms)
    * ![crypto-algos](../assets/crypto_algos.png)
    * Bitcoin uses ECDSA algorithm for asymm encryption - more mathematically complex than RSA. 
        - [x] [ECDSA](https://en.bitcoin.it/wiki/Elliptic_Curve_Digital_Signature_Algorithm) in bitcoin wiki 
        * Uses finite fields and a curve function [Secp256k1](https://en.bitcoin.it/wiki/Secp256k1)
        * private key: single unsigned 256 bit integer
        * public key: compressed keys with prefix of `0.x02` and 256-bit integer
        * signature: a number generated from a hash + private key (signing algorithm). public key can be used to determined the signature was produced from the has and private key (verification algorithm), without knowing the private key. 
        - [ ] [MOAR](https://medium.com/@blairlmarshall/how-does-ecdsa-work-in-bitcoin-7819d201a3ec)

- [x] Bitcoin source code: [ComputeMerkleRoot](https://github.com/bitcoin/bitcoin/blob/7fcf53f7b4524572d1d0c9a5fdc388e87eb02416/src/consensus/merkle.cpp#L45) called by [Miner.IncrementExtraNonce](https://github.com/bitcoin/bitcoin/blob/f63fc53c2aea2e33ce3195fe5e069447e2eddb1e/src/miner.cpp#L447) when [Mining.GenerateBlock](https://github.com/bitcoin/bitcoin/blob/f63fc53c2aea2e33ce3195fe5e069447e2eddb1e/src/rpc/mining.cpp#L111)

- [x] [4.](https://www.youtube.com/watch?v=w7HDA8gUbpQ) Blockchain Basics & Consensus
    * Byzantine General's problem: permissionless consensus, unknown participants. hard puzzle to solve, easy to verify.
    * Why leading zeros: from Hashcash - benchmarked to take a few seconds to write and email, but nanosecond to verify. 
    - [x] Hashcash original implementation uses [20 leading zeros](http://www.hashcash.org/dev/) - so a difficulty of [2^20 iterations](https://nakamoto.com/hashcash/). Each additional 0 doubles the number of iterations. 
        - [ ] Implementing a [hashcash server](https://replit.com/@nakamoto/Hashcash)
    * Targets average of 10 minutes per block generation time. Started at 8 leading zeros in 2009 to 18 leading zeros in 2018 > [difficulty chart](https://www.blockchain.com/charts/difficulty), [hash rate](https://www.blockchain.com/charts/hash-rate)
    * Mining pools - smoothing out economics rewards across individual miners. 
    * Pool [coordination](https://www.investopedia.com/tech/how-do-mining-pools-work/): managing the pool members’ hashes e.g. assigning ranges of nonce, looking for rewards, recording work performed by each pool member, and assigning reward shares to each pool member in proportion to the work performed - different payout strategies. Pool fees are 1-3%.
    * Network participants:
        * Full nodes: store full blockchain and can validate all txns
        * Pruning nodes - prune txns after validation and aging
        * Lightweight Nodes: simplified payment verification [(SPV)](https://en.bitcoinwiki.org/wiki/Simplified_Payment_Verification) nodes - only needs a copy of the block headers of the longest chain by querying network until longest chain is obtained
        * SPVs lets you validation your own txns w/o concern for other txns - same as a hot/cold wallet
        * Miners - perform POW and create new blocks. **Does not need to be full node** Most miners don't run full nodes, instead the operators are running full nodes. 
        * Wallets
        * Memory Pool: validated but unconfirmed transactions


- [x] [5.](https://www.youtube.com/watch?v=zGDTt9Q3vyM) Txns, UTXO, Script
    * Txn locktime (specified as block #): delays a txn from being included in a block until the specified block height (#) has passed. Used for delaying processing. 
    * Coinbase Txn: reward for solving POW. halves every 210k blocks.  
    * Coinbase Input: Block reward value, output: cannot be used as a txn input (i.e. spent) until after 100 bocks. 
    * Coinbase txns may include 100 bytes of arbitrary data 
    - [x] [UTXO](https://wiki.bitcoinsv.io/index.php/UTXO): unspent transaction output - all currently unspent txns. 
        * stored in a local database in levelDB
        * all bitcoin txns have at least 1 output (to receipient, or balance)
        * outputs are spent as inputs to other txns, must be unlocked with digital signature. 
        * UTXOs are collected into a **UTXO set** that represents current state of ownership of all BTCs in existence.
        * order: node receives txn -> node checks if input is spending a UTXO in the set (pulling additional inputs from unspent output (balance) -> ouput is taken out of UTXO set and stored in buffer -> when txn is accepted into block, UTXO is deleted from buffer
        * if txn is failed to be included in block, UTXO is returned to UTXO set.
        - [x] [Genesis upgrade in 2020](https://wiki.bitcoinsv.io/index.php/Genesis_upgrade): to reenable smart contracts, tokenization and other abilities for BTC beyond store of value.  
            * removes default block size limits for miners to customize. 
            * restore nLockTime and nSequence for Locktime (delay) features
            * disables pay-to-script PSH hash txns.
        * UTXOs offer [privacy benefits](https://river.com/learn/bitcoins-utxo-model/) by separately storeing each UTXO in a unique address, hide association between UTXO and public address. 



### Byzantine Fault Tolerance (BFT)

A BFT system is able to tolerate up to 1/3 of failing/malicious nodes

- [x] Byzantine Generals problem: [[Lamport](http://lamport.azurewebsites.net/pubs/byz.pdf)] [[Nelson](https://marknelson.us/posts/2007/07/23/byzantine.html) - defend against component failure with/without symptoms that prevent other components from reaching a consensus/agreement among themselves
    * **Also Interactive Consistency, source congruency, error avalanche, Byzantine agreement, Byzantine failure, Byzantine Fault**
    - Solution must pass three tests: termination, agreement, and validity.
        * Termination all correct processes eventually reach a decision regarding the value of the order they have been given.
        * Agreement All correct processes have to decide on the same value of the order they have been given.
        * Validity: If the source process is a correct process, all processes have to decide on the value that was original given by the source process.
    -  If the source process is faulty, all other processes still have to agree on the same value. If the General is bad, all lieutenants still have to come to a common, unanimous decision.
    - After receiving the order from source, all processes poll one anohter to check what orders each received from the source - check if source is faulty, or peer is faulty
    - Someone is lying, but _who_ is lying?
    - Naive solution: all lieutenants tell each other what the general message was, take the majority (2/3+1) solution as the correct value 
    - Lamport, Pease and Shostak Algorith: given _n_ processes of which _m_ are bad, and _n > 3m_.\
    - 1. Each lieutenant sends their own message to every other lieutenant except the general and itself (n-2). with each round, each lieutenant receives the message and its chain of participants e.g. {0, 132} - the value 0 from P1 to P3 to P2. 
    - 2. While sending messages, each lieutenant also gathers incoming messsages in a tree format - each node has 3 elements {input, path, output}. Each lieutenant calculates the majority value at each level of the tree and works up the tree. Resulting in the majority value of the root.   
    - in a n=7,m=2 where bad processes are P6,P7: 18 wrong values, 12 correct messages. 
    - Using the simple **overally majority** process in (1) will result in the wrong value. **Using a tree layout (2)**, by getting the majority in each leaf node per lieutenant, results in 4 correct messages vs 2 wrong messages. 

**BFT in Bitcoin network:** the network is asynchronous and is a replicated state machine. Participants are able to validate for bad peers or bad sources by forming a consensus based on all received-sent messages in the network and forming a 2/3 majority of the true state using POW - in which, cost of bad behavior significantly outweights good behavior, forcing a strong majority to convey true state.

- [ ] Lamport. Paxos Protocol and The [Part-Time Parliament](https://lamport.azurewebsites.net/pubs/lamport-paxos.pdf), state machine replication 


### Smart Contracts and Ethereum

> Set of promises, in digital form, including protocols, within which parties perform on promises. 
> - Nick Szabo, 1996

- [x] [6.](https://www.youtube.com/watch?v=JPkgJwJHYSc&t=9s) Smart Contracts and DApps
    - [x] Ethereum block headers contain [3 merkle trees](https://blog.ethereum.org/2015/11/15/merkling-in-ethereum/) instead of 1 in Bitcoin, each for: Transactions, Receipts and State 
        * Bitcoin-style light clients do have their limitations: (1) they can prove inclusion of txns, but not about the current state (asset holdings, name registrations).
        * A bitcoin light can query multiple nodes and trusting at least one of them will notify you of a txn spending - but **complex apps require txns to be aware of several previous txns** 
        * Ethereum light clients can answer the following: 
            * (txn) has this txn been included in a given block
            * (receipt) tell me all instances of event X emitted by address A in the last N days
            * (state) current balance of address A
            * (state) **pretend to run this txn on this contract - what would the output be?** - using state transition proof. 
        * **Merkle state transition proof:** local fake block, set to state S, pretends to be light client and apply txn. Server responds to all queries but tracks all response data. server also sends combined proof data from requests. client compares the response data and proof. 
        * Binary merkle are good for lists and append-only, static trees e.g. transaction trees _but not state trees_. 
        * State (balance) trees need: 
            * (1) fast calculation of new tree root after each insert/delete/update without recomputing entire tree
            * depth of tree is bounded to prevent DoSing the tree depth
            * **root of tree depends only on data, but not order of updates. **
    - [x] or rather, [**Merkle Patricia tree**](https://eth.wiki/en/fundamentals/patricia-tree)
    * Ethereum also does not have Transactions (input/outputs), but uses State Transitions
    * As as result, does not use UTXOs, but stores balances as accounts.
    * Bitcoin: transaction ledger, Ethereum: balance ledger

    * Block time is 14 seconds, instead of bitcoin's 10 minutes
    * Hash function: Ethash, instead of SHA256. 
        * ethash [[yellowpaper Appendix J](https://ethereum.github.io/yellowpaper/paper.pdf)] - designed to be **ASIC-resistant and easily verifiable with light clients**. 
    * Ethereum monetary policy has changed twice from 5 > 3 > 2ETH per block. 
    * Everything in cryptography, consensus is the same as bitcoin (in POW). 

- [x] [CDC](https://digitalchamber.org/wp-content/uploads/2018/02/Smart-Contracts-12-Use-Cases-for-Business-and-Beyond_Chamber-of-Digital-Commerce.pdf) - Smart Contract Use Cases
    * Digital Identity:
        * User self-sovereignity on personal data and sharing
        * Counterparties do not store individual data, reduced liability as a point of atack
        * frictional KYC with faster verification
    * Records: 
        *  Autorenew and autorelease for compliance automation reduces legal bills
        *  Automated processes and tracking of loans and collateral value reduces error and latency in filing
        *  Data archivals automatically becomes unsearchabes/unreplayable after disposal without occying warehouse
    * Securities:
        * enables t+0 settlement cycles
        * automatic payment of dividences and stock splits, proxy/delegated voting
        * removes counterparty risks from intermediaries
    * Trade Finance / Banking :
        *  Faster approval and payments with automated comliance and monitoring of credit conditions
        *  efficiency in creating, modifying, validating trade, title, transport-related agreements
        *  increased liquidity from ease of transfer and reduced fraud
    * Derivatives:
        * automatic settlement fromo triggers of trade events
        * automated external event processing and succession
        * realtime valuation of positions for realtime exposure and reduced errors 
    * Financial Data Recording
        * improved data integrity and transparency
        * reduced expenses for accounting systems 
    * Mortgages:
        * Automated relase of liens from land records when mortgage is paid off
        * increased visibility of servicer records to all parties for verification + tracking
    * Land Title:
        * reduced audit/assurance costs and streamlined processing.
        * Reduced manual processes in closing, escrow, etc. 
        * reduce land title fraud conveyance         
    * Supply Chain:
        *   simplified complex multi-party systems delivery
        *   granularity in inventory tracking and delivery assurance for insurance and risk, reduced fraud and theft
    * Auto Insurance: 
        * vehicles communicate with eachother and exchange/validate own condition, driving record, accident report hisotry.
        * vehicle self-awareness and damage
        * reduces duplication in report and policy verification
        * interesting [projects](https://www.disruptordaily.com/blockchain-use-cases-automotive/) in development already
    * Clinical Trials and Cancer Research:
        * Improved access to cross-institution data during epidemics with privacy-preservation 
        * Consent gathering and tracking for data acccess and patient privacy 

    
- [x] [Coindesk](https://www.coindesk.com/short-guide-blockchain-consensus-protocols): Short Guide to Blockchain Consensus Protocols e.g. POA, POS, POB, POC, POET. 
    * POS: no miners, instead validators/stakeholders and selected by stake size and paid in fees. Blocks are signed, and requirements differ between POS systems. 
    * PoActivity: Miners mine blocks (POW), blocks do not contain txn + random Validators sign on block (POS). If all selected validators are not available, new block + validators are reselected. Fees are split between minters and validators that complete a full block. 
    * PoBurn: miners burn native or alternative currency. More coins burned, higher chance of selection to mine. Burning coins is similar to spending compute power in POW. 
    * PoCapacity: pay with storage. More storage, higher chance of mining. Storage is used for data sets (plots). 
        - [ ] Proofs of Space: [whitepaper](https://eprint.iacr.org/2013/796.pdf)
    * Proof of Elasped Time (Intel): blocks are produced in random lottery using [TEE](https://en.wikipedia.org/wiki/Trusted_execution_environment)
        * TEE: isolated execution env with higher level of security.
        * TEE use cases: protects content on a device, no exposed to app developer or platform vendor. e.g. isolates application from mobile OS, infrastructure. 

- [x] PlanB: modeling Bitcoin's value with [Scarcity](https://medium.com/@100trillionUSD/modeling-bitcoins-value-with-scarcity-91fa0fc03e25) (Stock-to-Flow, S2F modelling)
    * _unforgeable costliness, scarcity_
    * _existing stockpiles of btc in 2017 was 25x minted btc.
    * stock = reserves, flow = production/mint. supply growth rate = flow/stock. SF = 1/supply growth.
    * Gold SG: 62, silver SF: 22, Palladium: 1.1, Platinum: 0.4. 
    * BTC 2021 supply: 18.73M BTC, flow: 900 BTC/day, S2F: 57. [stats](https://www.blockchain.com/charts#currency)
    * different models take into account lost BTC supply, original 1M minted by Satoshi etc. 
    * where would money inflow to BTC market value come from? other commodity markets and economies. 
    * validating that BTC is driven by SF using power law: **Market value = exp(14.6) * SF^3.3**. 
    * power law: change in P results in exponential change in Q independent of size. 
    * BTC market crashes in 2011, 2014, 2018 are in different scales (10, 1000, 10000). 


- [x] 2018. Bitcoin, the [Mises Regression Theorem](https://mises.org/library/bitcoin-regression-theorem-and-emergence-new-medium-exchange) and emergency of a new medium of exchange 
    * Mises Regression Theorem: a _money_ is a _good_ with objective value from its own direct use, becomes later valued as function in indirect excahnge. 
    * condition that no MOEx exists in that economy (completely barter economy)
    * _Is bitcoin money, and does it refute the MRT?_: whether MRT is applicable to cryptocurrencies, which are not backed by any commodity. 
    * Faggart: _we must.. identify when bitcoin went from being a “consumer good” to being used in indirect exchange_
    * Suede, Murphy: Object does not need to be valued directly before being a MOEx. 
    * Critics: Paper money replacing paper money - German Rentenmark, the Euro, Argentinian Credito (over Peso). Psychological factors, legal tender laws, government assurance and redeemability against older currencies make it possible for new money against the MRT. 
    > _Does BTC violate MRT?_: _analyzing the actors’ motivations, and the factors that induced their confidence is beyond the scope of the regression theorem or any praxeological discussion_
    * if BTC becomes money, it is the first **non-commodity money in absence of legal-tender laws**, govt and institutional backing
    * Surda: the _truly unique functions of BTC are non-monetary_: effective notarization, smart prperty, conditional transfers, eliminates intermediaries, form stock ownership, transaction aduiting. 
    * Mises: once a medium is accepted by the public as money, its underlying direct use (e.g. jewelry for gold and silver) can disappear entirely. 
    * _Bitcoin does not need to have a direct-use value in order to be a medium of exchange, because it did not emerge from a pure barter economy_
    - [x] El Salvador passes Bitcoin as [legal tender](https://twitter.com/nayibbukele/status/1402446890466217985)
    * BTC and USD exchange rate is freely established by the market
    * Prices and tax can be paid in BTC. All economic agent must accept BTC as payment
    * BTC exchanges are not taxed as capital gains as it is legal tender. 
    * Accounting remains in USD. 
    * State guarantees a Trust for auto/instant conversion of BTC-USD. 

- [x] [7.](https://www.youtube.com/watch?v=GLVrOlHLJ1U) Technical Challenges
    * Centralization vs Decentralization (Coase): Costs of Capture, Rents, SPOF vs Costs of Coordination, governance, security, stability moves market preference. 
    * VB Trilemma: scalable, decentralized, secure. _working enough_. 
    * Sidechain analogous to commercial banks settling with central bank.
    * Sidechains validate txns and block - mainchain validates the chain state after _condensation_ 
    - [ ] 21st Geneva Report: Blockchain on Finance [paper](https://voxeu.org/content/impact-blockchain-technology-finance-catalyst-change)
    * hard forks: software updates which are not backwd compatible because older sw version cannot validate new blocks e.g. change in block size. 

- [x] Shyft Network: Understanding [Trie Databases](https://medium.com/shyft-network-media/understanding-trie-databases-in-ethereum-9f03d2c3325d) in Ethereum
    * Tree: data struct, hierarchical linked nodes. _Trie_: tree-like data structure to hold an associative array i.e. re***trie***ve. _Tries_ are also claled prefix trees, radix trees or digital trees.
    * Tries: retrive a string value by traversing down a branch of nodes that store assoicated references/keys that lead to end value. 
    * keys with same sequences are grouped in close proximity to reduce time to travel down a branch. keys can be strings of characters instead of individual characters to improve efficiency in value look-up.
    * merkle trees: leaf nodes - hash of block, non-leaf nodes - hash of the labels of children. 
    * merkle tree properties: consistency/verification + fast to verify + only requires part of the tree for verification (starting from root, check hashes of only subtree)
    * light clients can also perform verification - light clients receive merkle root in block headers, which can be used to query full nodes for verification.
    * **Modified Merkle Patricia Trie**: cyrptographically authenticated - Deterministic: a trie with same (k,v) is guaranteed to be exactly the same. _cryptographically secure_.
    * each node is referenced by hash for leveldb/rocksdb lookup. root nodes are a cryptographic fingerprint of _entire_ data structure to speed up insert/lookup/delete. 
        * leveldb features: 
            * data is stored and sorted by keys. 
            * caller-custom comparison functions. 
            * ordered mapping from string keys to string values
            * multiple changes in single atomic batch 
            * fwd/bkwd iteration
            * autocompressions using snappy
    * **Hex-prefix (HP) encoding**: encoding _paths_ between trie nodes - (1) disambiguate leaf vs extension nodes, (2) convert path to even length for tree to be a _whole number of bytes_.
        *  Node types: 
            *  (1) Leaf - has a terminator/flag - the last byte of the path. 
            *  (2) Extension. 
        *  In encoding, Nibbles (single-hex) may be used to ensure path is always an _even_ length.
            *  Odd-length extensions are prepended with nibble
            *  even-length leafs: i. terminator is removed, ii. added with 2 hexes for even-length
            *  odd-length leafs: i. terminator is removed
    *  **Recursive Length Prefix (RLP)**: encoding _value_ / data serialization, planned to be replaced with new serializer.
        * encode nested arrays / byte array (item) or list of item.
        * Node types: 
            * `NULL`: empty string
            * `BRANCH`: 17-item node looks like [v0,..v15, vt]
            * `LEAF`: [encodedPath, value]
            * `EXTENSION`: [encodedPath, key]
        *   extension nodes are used for skipping ahead nodes with no differing paths or index values, using a _partial path_ for lookups
    *  **Ethereum Tries**: root for each tree is Keccak-256 hash, and **Receipt+State+Transaction Trees are in the block header.** Storage Tree root is in the RLP encoded value. 
        * (1) Transaction Tree: records transactions. Input params (account nonce, gas, recipient, transfer value etc.)
        * (2) Receipt Tree: records txn outcomes, used for ZKPs and searches. Input params (post-txn state, gas used, logs, log bloom filter)
        * (3) State Tree: global state trie, contains [ethereum address, RLP-encoded account (nonce, blanace, root, hash)]. Constantly updated.
        * (4) Storage Tree: contract data, each account has a separate storage trie. 

- [x] Coinmoinks: [Querying data](https://medium.com/coinmonks/querying-data-in-an-ethereum-blockchain-86289d3fc385) in an Ethereum blockchain 
    * state variables: stores state of smart contract by saving the values in a block on the blockchain, works like a _global_ variables as they are defined in the `contract` section
    * local variables: only save values within the execution of the function
    * confirmed transactions -> transaction trie
    * temporary data (local vars, account adress) -> state trie for changes and updates
    * State trie [address, RLP encoded (nonce, balance, storageRoot, account hash]
    * Storage tree - stores all contract data, separate tries for each account. a 256b hash is stored as the `storageRoot` in the State trie.
    * 1. Accessing data using Geth and LevelDB:
        * geth downloads complete blockchain and indexes with levelDB/rocksDB for lookup 
        * query levelDB returns encoded results
    * 2. Using a block explorer: etherscan
    * 3. web3.js to access events data on the Ethereum blockchain
        * an event listener + callback using `contract.events.allEvents()` 
        * specific event listening: `contract.events.EventName()`
    - [ ] Reading Ethereum Geth database using [LevelDb](https://etherworld.co/2019/02/06/reading-ethereum-geth-database-leveldb/)

- [x] How to [Query and Monitor](https://www.pauric.blog/How-to-Query-and-Monitor-Ethereum-Contract-Events-with-Web3/) Ethereum Contract Events with Web3
    * [`code/web3_events.js`](../code/web3_events.js)

- [x] **Ethereum [Whitepaper](https://ethereum.org/en/whitepaper)**

**Bitcoin as a State Transition System**: State: balance or ownership of existing BTC, state transition function: state + txn -> new state. error when account has insufficient state for transition.
    * **Bitcoin State transition function:** `APPLY(S,TX) -> S' or ERROR` 
    * Bitcoin _state_ is the collection of all UTXO with each UTXO having a denominated value and owner. Txns have one or more inputs, each referring to a UTXO and signature produced by the private key, and one or more ouputs containing a new UTXO. 
    * (1) for each input in TX, if the input UTXO is not in S -> error. if signature does not match input UTXO owners -> error
    * (2) if sum of value of all input UTXO is less than sum of value of all output UTXO -> error
    * (3) return S' with SUM(output UTXO) - SUM(input UTXO)
    * **State Transition in a consensus system**: 
    * (1) Check previous block exists and is valid
    * (2) Check timestamp of current block is greater-than but less than 2 hours ahead
    * (3) check POW on current block is valid
    * (4) Let `S[0]` be state of previous block
    * (5) Apply state transition `S[i+1] = APPLY(S[i],TX[i])` on all txn in the block's txn list
    * (6) Return `true` and register new state `S[n]` - `n` being the # of transactions. 
    * The state is not encoded in block, but is _remembered_ between blocks, computed by sequentially applying every txn in every block. 
    * **Ordering of txns matter**: given two txns A and B such that B spends UTXO created by A, **the block can be invalid if B is ordered before A in the block.**
    * POW is a control mechanism /validity condition that is separately required using an adjusted target to add computation difficulty to prevent sybil attacks. SHA256 is an unpredictable pseudorandom function, forces exhaustive trial-error.  

**Ethereum Philosophy**

i. simplicity - simple for the average programmer to implement
ii. universality - no features, underlying turing-complete scripting language
iii. modularity - decomposable, different components are implemented as separate, complete libraries to maximally benefit overall ecosystems, even other protocols
iv. agility - making modification as opportunities are discovered with high-level roadmaps
v. non-discrimation, non-censorship - not attempt to oppose specific undesirable applications. 

**Ethereum account**: nonce, ether balance, contract code (present if not EOA), storage (empty by default).
    * contract accounts: execute code everytime account receives a message, read/write to internal storage, send messages,  create contracts. autonomous agents, not legal contracts.

**Transactions**: signed data package containing messages from an EOA.
    * recipient, signature of sender, amount of ETH transferred, optional data field, `STARTGAS`, `GASPRICE`
    * `STARTGAS`: max number of computational steps allowed for the txn 
    * `GASPRICE`: the fee the sender pays _per computational step_
    * gas as a anti-DOS to prevent accidental/malicious infinite loops or resource wastage
    * complex operations, or operation that store more data cost more gas
    * additional 5 gas fee for every byte in txn data

**Messages**: **from contract to contracts**. Messages are virtual objects, exists only in the Ethereum execution env. 
    * sender (implicit), recipient, Ether, data (optional), `STARTGAS`
    * when a contract executes the `CALL` opcode. contracts receiving a message will execute its code like receiving a txn.
    
* Gas allowance applies to the **total gas of the txn + sub or _relayed_ executions**. 
    
- [x] **Ethereum [State Transition](https://ethereum.org/en/whitepaper/#ethereum-state-transition-function)  function**. `APPLY(S,TX) -> S'`
    1. check of txn is well-formed for sufficient value, **signature is valid, and nonce matches sender's account nonce**
    2. calculate fee as `STARTGAS * GASPRICE`. get sending address from signature. subtract sender balance and increment sender nonce
    3. `GAS=STARTGAS` and subtract `5 gas * transaction bytes`
    4. Transfer value to receiver, and/or **create the receiver account**. if the receiver is a contract, execute contract code.
        * the burn address `0x0000` technically exists, but infeasible to create
    5. If transaction fails, all state is reverted **except fees is still paid to miner**
    6. **refund fees for remaining gas to sender**, send fees paid to miner.
        * you can set a higher `STARTGAS` - all excess gas is refunded.  

**Code Execution**

Code execution is an infinite loop that repeated carries out ops at the program counter `pc`, increaments the counter until the end of the code is reached, or `STOP` or `RETURN` is detected.

3 data storage spaces:
1. stack LIFO
2. memory - infinitely expandable byte array
3. contract long-term [key,value] storage. only contract storage persists - stack and memory are rest at the end of the computation.

execution model computational state is tuples of (`block_state, txn, message, code, memory, stack, pc (counter), gas`). on each round/tuple:
- take pc-th byte of code
- perform code (modifies memory/stack/storage)
- subtract gas
- increment pc

**Blockchain**
Same as bitcoin, except Ethereum block:
* Also contains **current state** separately, block number and **difficulty** stored in block (not adjusted)

Sequence: 
1. Prev block exists and isv alid
2. Timestamp of previous block has past, but is **less than 15 minutes** from current block
3. check block number, difficulty, txn root, uncle root, gas limit are valid
4. check POW
5. `APPLY(S,T) -> S'` on all transactions in block. If _app returns error_ OR _total gas consumed by block exceeds GASLIMIT_, return error.
6. Set new state and pay reward to miner
7. **Check Merkle tree root of state `S_FINAL` is equal to final state root in current block header**

Storing entire state in each block does not significantly tax performance because state is stored in tree and only small parts of the tree is updated. **Patricia tree**. Since the last valid block cointains state history, there no need to store entirety of blockchain hisory. 

- [x] The [EVM](https://medium.com/mycrypto/the-ethereum-virtual-machine-how-does-it-work-9abac2b7c9e): How does it work? 
    * smart contract languages like Solidity are not executed by EVM directly - compiled to low-level machine instructions, **opcodes**. 140 unique opcodes allow the EVM to be Turing-complete. 
    * Opcodes are 1 byte, so there can onl be a maximum of 256 opcodes. 
        * Stack opcodes: POP, PUSH, DUP, SWAP
        * Aritmetic & Logic: ADD, SUB, GT, LT, AND, OR
        * Environmental: CALLER, CALLVALUE, NUMBER
        * Memory: MLOAD, MSTORE, MSTORE8, MSIZE
        * Storage: SLOAD, SSTORE
        * Program counters (PC): JUMP, JUMPI, PC, JUMPDEST
        * Halting: STOP, RETURN, REVERT, INVALID, SELFDESTRUCT
    * opcodes are stored as **bytecodes**, each opcode is a byte. bytecodes are decoded into opcodes during execution. the bytecode `0x6001600101` is executed as `6001` (PUSH), `6001` (PUSH), `01` (ADD).
    * the EVM uses a **256-bit register stack** with acess to only the **most recent 16 items**, and a max of **1024** items. 
    * complicated opcodes have to use **contract memory** for data storage/access. contract memory is only available during the contract execution, is not persistent.  
    * persistent storage (**contract storage**) works like a database for future contract executions and can be read externally. writing to contract storage is **6000x** more expensive than memory. 
    * each opcode as a base and dynamic gas cost depending on complexity. - Yellowpaper, Appendix G. 
    * opcodes that reduce state size refunds gas e.g. setting storage to 0, SELFDESTRUCT. but **a refund cannot exceed half the gas used for call**
    * deploying a contract creates a txn w/o a `to` address. 
    * contract code consists of a _creation bytecode_ (for constructor) and _runtime bytecode_. creation bytecode is only called on deploy, runtime bytecode is on every contract call.
    * the contract bytecode (`0x60..`) is the concatenation of bytecodes and can be decoded into opcodes to look at constructor, opcodes (variable assignments etc.) and metadata Swarm hash.
    * the **Swarm hash** is a (experimental) decentralized file storage. appended to the runtime bytecode, will never be interpreted by EVM as the EVM can only react 1024 items.
    * Decompile bytecode with: [Etherscan](https://etherscan.io/bytecode-decompiler), [Eveem](https://eveem.org/), [EtherVM](https://ethervm.io/) - but some parts of the source code can be lost due to compiler optimization. 
    * Compare common function signatures using [4byte](https://www.4byte.directory/signatures/). 
        * Function signatures are the first 4 bytes of hash(function name, inputs)
        * helloWorld() [empty inputs] has a signature of [`0x7fffb7bd`](https://www.4byte.directory/signatures/?bytes4_signature=0x7fffb7bd)
    * Arguments passed to a function are added in 32-byte pieces (words) after the signature hash. 
        * if an argument is over 32bytes, it is split into multiple words which are added into the input data after all arguments. 
        
- [x] Understanding [event logs](https://medium.com/mycrypto/understanding-event-logs-on-the-ethereum-blockchain-f4ae7ba50378) on the Ethereum blockchain
    * Opscodes for event log emission: LOG0 `0xa0` .. LOG4 `0xa4` for log records between 0-4 topics. Log records contain topics and data. 
    * Topics are 32-byte words to describe an event. The first topic is usually a **signature** of the name of the event, including parameter types - except **anonymous events**
        * arrays and strings cannot be used in topics and should be included as **data**, or hashed. But hashed topics require knowledge of input.
        *  Topics should only be used for data that strongly narrows down search queries like addresss. Topics serve has index keys of an event that map to the same value.
        *  Topics are searchable, data is not. but data is cheaper than topics and supports larger values. 
    *  A contract declares `events` - name and inputs e.g.: `event Transfer(address indexed _from, address indexed _to, uint256 _value)`.
        * in function call, `emit Transfer(foo, bar, 100)`
    *  Generate event signature as Keccak256(`Transfer(address,address,uint256)`) -> `ddf25..`
    *  `indexed` arguments are treated as additional _topics_
    *  unindexed arguments are treated as _data_
    *  Can now lookup _all Transfer events from address X to address Y_, but not for a given value. 
    *  This logging operation will be a `LOG3` opcode. `LOG3` opcode requires 5 arguments `LOG3(memstart, memlength, topic1, topic2, topic3)`. This part is handled by higher level languages like solidity, vyper.
    *  Reading event logs using web3 `subscribe`. 
    *  **Logging base cost is 375 gas  + 375gas x number of topics + 8gas x byte of data.**
    *  1 unit of gas is some value of gwei. 


### Ethereum Stages

1. Frontier
2. Homestead
3. Metropolis - Byzantium and Constantinopole
    - [x] Constantinopole [[Consensys](https://media.consensys.net/the-constantinople-hard-fork-what-you-need-to-know-d438a91dec3f)], [[BlockGeeks](https://blockgeeks.com/guides/ethereum-constantinople-hard-fork/)]: bitwise shifting, optimize large-scale code, SSTORE gas optimization, CREATE2 or state channels, remove difficulty bomb and block reward reduced to 2 ETH.
    * Difficulty Bomb / Ice Age: increase energy required to mine a new block until it beomes impossible to mine. To force transition into POS. EIP 1234 delays the implementation of the Bomb by 12 mos. 
    - [x] [EIP 1234](https://eips.ethereum.org/EIPS/eip-1234): Difficulty Bomb delay due to Casper and POS delays. 
    * client calculate diificulty based on a fake block number that delays the bomb by 5M blocks. 
5. Serenity (2.0) - POS


### State Channels

- [x] [EthHub](https://docs.ethhub.io/ethereum-roadmap/layer-2-scaling/state-channels/) 1. State is locked via multisig or smart contract with specified participants
        * participants update state among each other by constructing and signing txns without submitting to blockchain
        * submit state back to blockchain and close state channel and unlocks state

| State Channels | Side Chains |
|:---------|:------|
| * privacy - limits visibility betw. channel participants| * all txns are published in sidechain |
| * instant finality, signed state in a s. channel can be considered final || 
| * 100% participants in the multisig must be available. | |
| * best for known participants - can be added/removed with new contracts | * no limitation on participant changes |
| * best for multiple state updates over a longer period of time due to initial cost to create a channel ||
|| * sidechains are permanent (no need to close). assets are locked on sidechain to move back to mainchain. |
|| * since participants can be added/removed, there's no need for new chains |
|| * sidechains do not share security with mainchain - users on sidechains must trust the security of the sidechain itself. sidechains must have enough miners on their network unlike state channels |
||* sidechains need federation - additional layer (servers) as intermediate points between main chain and sidechain to lock/release coins.  |


## Understanding Curve 

_Invariant_ is a property of a mathematical object (or a class of mathematical objects) which **remains unchanged** after operations or transformations of a certain type are applied to the objects

- [x] [StableSwap Exchange](https://curve.fi/files/stableswap-paper.pdf) for stablecoin / pegged-assets liquidity
    * low price slippage (1/100x Uniswap) for demands, multi-stablecoin savings account with 300% APR for supply. 
    * Sigma and Pi [Notation](https://mathmaine.com/2010/04/01/sigma-and-pi-notation/)
    * Constant Product for ETH etc. Constant sum for stables. Constant Product MMs have higher slippage and very small returns for stables. 
    * given two coins x, y: dy/dx is price. slippage_x is dy/dx against dx or d2y/dx2
    * Amplified or leveraged invariant: d2y/dx2 -> 1 when dx -> 0, d2y/dx2 -> 1/x when dx -> inf. 
    * ![amplified invariant](../assets/amplified_invar.png)
    * low leverage: market is constant product (high slippage). high leverage: market is constnat sum (low slippage)
    * **at high leverage, market is constant sum (low slippage). which is good for stables.**
    * taking χ as a dynamic value: constant A x Constant Product function. Converge for D (total coins at equal price)
    - [x] Converging D [code using Newton method](https://github.com/curvefi/curve-crypto-contract/blob/master/contracts/CurveCryptoMath3.vy#L90)
    * ![stableswap invariant](../assets/stableswap_invar.png)
    - [x] SerenityFund: the Magic [Amplification Coefficient](https://serenityfund.medium.com/company-watch-curves-formula-for-stablecoins-swap-and-the-magic-amplification-coefficient-d998ed1e184b)
    * Large A for coins that are unlikely to peg. INF A becomes [mStable](https://app.mstable.org/#/musd/save), all tokens are 1:1 swaps.
- [x] [Pools](https://curve.readthedocs.io/exchange-pools.html#exchange-pools-a)
    * Amplification coefficient: The amplification co-efficient (“A”) determines a pool’s tolerance for imbalance in its assets. implemented as 1/A - higher A values means the pool allows for **less** slippage when imbalance is high. 
    * Plain pools: stablecoins pool. 
    * Lending pools: wrapped tokens, underlying asset is lent out to e.g. aave, yearn, compound
    * Metapools: stablecoin + LP token e.g. gUSD + 3CRV (from 3Pool plain pool) for additional trading fees. 

- [x] [Constant Function](https://medium.com/bollinger-investment-group/constant-function-market-makers-defis-zero-to-one-innovation-968f77022159) Market Makers (CFMMs) vs AMMs: 
    * CFMMs as a subset of AMMS
    * Bonding curves: relationship between price - **token supply**. CFMMs use relationship between **two or more tokens**, so not a bonding curve. 
    * Constant Functions _def._ any trade exchanges must **conserve the overall reserve (constant)**. Abitrageurs maintain price of assets within that portfolio based on market price.
    * CFMM participants: Traders, LPs, Arbitrageurs
    * Constant Product (x\*y=k): as x -> INF, or y -> INF, liquidity (∫) never -> 0. 
    * Constant Sum (x+y)=k: Zero slippage as dydx=0, but liqudity (∫) is not infinite and can be drained by arbitrageurs.
    * Constant Mean: generalized Constant Product for n>2 assets. (x\*y\*z)^(1/3)=k
        * e.g. Balancer 
    * Hybrid CFMMs: i.e. curve, [shell](https://shellprotocol.io/)
* **CFMM pros:**
    * immediate exchanges without using orderbooks
    * bootstrapping liquidity using liquidity pools from passive lenders - no internal trading desk or upfront assets
    * onchain oracles - blocks record the price right before the first trade.
    * path independence - price between two assets solely depend on their relationship to each other in an LP, not the path between them. 
* **CFMM cons:  **
    * Slippage: tendency of prices to move against the trade _as the trade absorbs liquidity_. Order sizes should be small to minimize slippage.
    * complex financial risks e.g. IL.
* Future of CFMM:
    * Specialized CFMM for different assets
    * Liquidity sensitivity on other factors than price e.g. volume, dynamic fees etc.
    * Bootstrapping primary market asset issuance.

- [ ] Relevant Community: What are [Bonding Curves](https://blog.relevant.community/how-to-make-bonding-curves-for-continuous-token-models-3784653f8b17)

### Curve V2

Objectives: 

* _liquidity for assets which aren’t interpegged, but more efficient than xy = k_
* liquidity concentration with current dynamic _internal oracle_ price, changes when loss is smaller than system profit. for 5-10x higher liquidity. 
* Amplification factor A and gamma are autoadjusted for converging on invariant D. 
* fees are dynamic
* 

- [x] AMM with [dynamic peg](https://curve.fi/files/crypto-pools-paper.pdf)
    * Invariant is represented as a _hypersurface_: ordinary surface in three-dimensional space to the case of an n- dimensional space.
    * _When we change (price coefficients), the price peg (between all tokens in pool) changes but balances of each token don't._ 
    * _We can calculate the invariant D for the new values of (transformed balance) and substitute new D and (price coefficients) to calculate (cost/profit). 
    * We allow the reduction in Xcp (cost/profit) but only such that the loss of value of Xcp (cost/profit) doesn’t exceed half the profit we’ve made (which we track by tracking
the increase of Xcp)._
    * CurveCrypto invariant: 
    * ![curvecrypto_invar](../assets/curvecrypto_invar.png)
    * the leverage variable χ from stableswap, is this, **K**, is a function of A (amplification) and γ (distance of two constant product functions)(small value)
    * ![new_leverage_function](../assets/new_leverage_function.png)
    * for a pool of coins xi, we calculate for D. 
    * _safe values for converging D: `1<A<10E4, 10E-9 < x0 (based currency) <10E15, 10E-5 < xi/x0 (price ratios) < 10E5, 10E-8 < γ < 10E-2`_
    * e.g. in stableswap paper, for χ= 30000, optimal A=85.  
    * p (coefficients) are adjusted when the last real Xcp (cost/profit) is less than last calculated 0.5 x Xcp (from internal price oracle). 
    * ![cost-profit-function](../assets/cp_function.png)
    * The internal price oracle is an EMA by N-dimensions of prce. 
    
- [x] curvecrypto [contract](https://github.com/curvefi/curve-crypto-contract/blob/master/contracts/matic/CurveCryptoSwapMatic.vy)
    * [`add_liquidity`](https://github.com/curvefi/curve-crypto-contract/blob/master/contracts/CurveCryptoSwap.vy#L707), `remove_liquidity` calls `tweak_price`
    * `tweak_price` parts: 
        * updates oracle EMAs: [alpha](https://github.com/curvefi/curve-crypto-contract/blob/master/contracts/CurveCryptoSwap.vy#L461)
        * calculates initial `newton_D` for 35k gas 
        * updates oracle prices or calculates from initial price_list for 70k gas for 3-token pool.
        * calculate new profit using virtual_price
        * recalculates new `newton_D` for change in [balance*prices]
        * checks for price adjustments, or virtual_price > profit + `ALLOWED_EXTRA_PROFIT`
        * or, readjust for new price prices, price_threshold must be more than adjustment_step
        * recalculate D from A, gamma, price_list until gets new profit with new parameters.
        * recalculate new prices xp
        * recalculate virtual_price from geometric mean of xp: see _Quantification of a repegging loss_
        * update parameters: D, price_scales, virtual_price.



## Defi Security 

- [x] The Fvckrender hack [post-mortem](https://manifoldxyz.substack.com/p/the-fvckrender-hack-post-mortem)

## Governance

- [x] UniV3 on Arbitrum [vote](https://gov.uniswap.org/t/deploy-uniswap-v3-to-arbitrum-mainnet/12451) [passed](https://snapshot.org/#/uniswap/proposal/Qmehop1NNWP9VEf7tGLEAYRphVsXtdxkL7oKEhaXL2Xao6)
    * Univ3 is licensed under [BSL 1.1](https://uniswap.org/blog/uniswap-v3/) - no forks up to 2 years. 
    * Current plans for integration with Optimism, but Arbitrum has far less risk of reaching a non-deterministic state and it can be used with the same contract bytecode as used for Ethereum L1 contracts.
    - [x] Optmism vs Arbitrum: 
        * L2s, optimistic (fraud proofs), sequencers
        * difference. - what happens when two partieis disagree on a state
        * Optimism: single round fraud proofs: L1 executes whole L2 on-chain for verification for instance FP (fraud-proofing) (containerization)
        * Arbitrum: multi round fraud proofs: binary search to find first opcode of a contended block in AVM. Slower between 1-2 weeks for FP. (virtualization)
        * Optimism FP may not support hardforks, opcodes may be removed or modified. 
- [x] UniV3 on xDai [vote](https://gov.uniswap.org/t/deploy-uniswap-v3-to-xdai-chain/12508) [open]
    * xDai - latest EVM patchset (berlin) and supported by 2 clients: openEth and Nethermind. dPoS
    *  multichain interop with distributed governance board
    *  increased block capacity by 30% 
    *  xDai [omnibridge](https://omni.xdaichain.com/bridge)


## How to DeFi

- [ ] The Vaults at Yearn [(June 3rd 2021)](https://medium.com/yearn-state-of-the-vaults/the-vaults-at-yearn-9237905ffed3)
   * yveCRV-DAO / [backscratcher]: takes CRV, additional fee earnings on top of staking in curve. claimed as 3crv
- [ ] Seba Bank on [Yearn Finance](https://www.seba.swiss/research/yearn-finance-decentralised-asset-management)
- [x] [Bloomberg](https://archive.is/2021.06.07-093617/https://www.bloomberg.com/news/articles/2021-06-07/bitcoin-btc-vs-ethereum-eth-and-defi-there-s-a-big-difference) on DeFi
- [x] Quickswap QUICK [tokenomics](https://quickswap-layer2.medium.com/quick-tokenomics-liquidity-mining-details-96-75-distributed-to-the-community-3dbffd6ba214): 90% liquidity mining over 4 years, 5% to UNI LPs, 3.25% to creators, 1% for future airdrop, 0.75% marketing
- [x] Everything about [dQUICK](https://quickswap-layer2.medium.com/everything-you-need-to-know-about-dquick-the-dragons-lair-e2df6fb861af)
    *  0.04% (out of the 0.30% fee) of volume trades are used to market buy QUICK and distribute it to dQUICK stakers. 
    - [x] [Contract](https://explorer-mainnet.maticvigil.com/address/0xf28164A485B0B2C90639E47b0f377b4a438a16B1/contracts) + [extract](../code/dquick.sol)
- [x] Coindesk: Making Sense of [CryptoEconomics](https://www.coindesk.com/making-sense-cryptoeconomics)    
    * [mechanism design](https://en.wikipedia.org/wiki/Mechanism_design): economics and game theory in desining mechanism or incentives where players act rationally. 
    * Cryptoeconomics requires us to think about information security problems in economic terms. _Security guarantee in a distributed system_
    * 1. Consensus protocols: including Eth resistance to mining centralization
    * 2. Application tokenomics
    * 3. State channels: moving cheaper processes off-chain before sending the final state to blockchain


## Unsorted

- [x] Ruby [Sidekiq](https://longliveruby.com/articles/sidekiq-good-practices) best practices

## General News

- [x] Rundown on FBI "recovery" of DarkSide Colonial Pipeline [hack](https://dossier.substack.com/p/the-colonial-pipeline-hack-the-russians)
    * DOJ claims to have _hijacked DarkSide's Bitcoin wallet_ to seize 63.7 BTC.
    * DOJ actually traced and issued warrant to a custodian wallet based in NorCal, most likely an exchange. 
    * Note that US-regulated exchanges are KYC-ed and do not serve Russian users (DarkSide is allegedly Russian)

- [x] Snapshot: decentralized [voting](https://decrypt.co/resources/what-is-snapshot-the-decentralized-voting-system)
    * uses IPFS without on-chain verification, making voting fee-less.
    * voting with NFTs
    
- [x] Bitcoin 2021: Letter from Julian Assange - excerpt from [Cypherpunks: Freedom and the future of the internet](https://www.youtube.com/watch?v=_KgEjRKTZ9A) [book](https://www.amazon.com/Cypherpunks-Freedom-Internet-Julian-Assange/dp/1944869085)
    *  Assange Defense Fund: [Official Links](https://defend.wikileaks.org/donate/), [GoFundMe](https://www.gofundme.com/f/julian-assange-amp-wikileaks-public-defense-fund/update/26498466/gallery/0)
