# Sprint 2 - 06/07

## Blockchain & Money. MIT 15.s12

Gary Gensler Goldman Sachs, US Treasury, MIT, SEC chairmain (2021)

- [x] [3.](https://www.youtube.com/watch?v=0UvVOMZqpEA) Blockchain Basics and Cryptography
    - [x] Cryptographic primitives: **(1) hash functions** for tamper resistance/integrity and (2) **digital signatures using asymm encryption** for  consent. 
    * Blockchain primitives - crytography and consensus
    * components of a block: 
        * Header: hash of previous block + timestamp + nonce + **merket root hash**
        * Own Hash Header
        * Txn list    
    * Solving the puzzle: having a **certain number of leading zeros**. It doesn't mean having the exact, identical hash. 
    
    >
    > The proof-of-work involves scanning for a value that when hashed, such as with SHA-256, the
hash begins with a number of zero bits.
    >
    > Avg work required is exponential to the number of zero bits required. W=e^n
    > Merkle tree is a binary tree of hashes.
    * Merkle tree: [hash of hashes of blocks](https://www.investopedia.com/terms/m/merkle-root-cryptocurrency.asp) for quick, mathematical verification
    * The [merkle root of a block](https://www.youtube.com/watch?v=V6gLY-1G4Mc), which is the hash of all hashes of all txns, contains info on all txns in the block.
    * One branch of a hash tree can be donwloaded and verified immediately even without the whole tree. Only small blocks of data need to be redownloaded and quickly checked. 
    * Any modified txn will change the value of the Merkle root of the block, and so the integrity of the block.
    * For an odd # of txns (2n-1) in a block, the last txn pair is duplicated for L1 hash to have 2 leafs
    * Digital signatures and asymmetric encryption: public + private key
    - Bitcoin addresses are not simply public keys to the private keys. 
    - **Bitcoin addresses = base58(public key x SHA256() x SHA256() + checksum)**


- [x] Cryptographic algorithms [overview](https://www.cryptomathic.com/news-events/blog/differences-between-hash-functions-symmetric-asymmetric-algorithms)
    * ![crypto-algos](../assets/crypto_algos.png)
    * Bitcoin uses ECDSA algorithm for asymm encryption - more mathematically complex than RSA. 
        - [x] [ECDSA](https://en.bitcoin.it/wiki/Elliptic_Curve_Digital_Signature_Algorithm) in bitcoin wiki 
        * Uses finite fields and a curve function [Secp256k1](https://en.bitcoin.it/wiki/Secp256k1)
        * private key: single unsigned 256 bit integer
        * public key: compressed keys with prefix of `0.x02` and 256-bit integer
        * signature: a number generated from a hash + private key (signing algorithm). public key can be used to determined the signature was produced from the has and private key (verification algorithm), without knowing the private key. 
        - [ ] [MOAR](https://medium.com/@blairlmarshall/how-does-ecdsa-work-in-bitcoin-7819d201a3ec)

- [x] Bitcoin source code: [ComputeMerkleRoot](https://github.com/bitcoin/bitcoin/blob/7fcf53f7b4524572d1d0c9a5fdc388e87eb02416/src/consensus/merkle.cpp#L45) called by [Miner.IncrementExtraNonce](https://github.com/bitcoin/bitcoin/blob/f63fc53c2aea2e33ce3195fe5e069447e2eddb1e/src/miner.cpp#L447) when [Mining.GenerateBlock](https://github.com/bitcoin/bitcoin/blob/f63fc53c2aea2e33ce3195fe5e069447e2eddb1e/src/rpc/mining.cpp#L111)

- [x] [4.](https://www.youtube.com/watch?v=w7HDA8gUbpQ) Blockchain Basics & Consensus
    * Byzantine General's problem: permissionless consensus, unknown participants. hard puzzle to solve, easy to verify.
    * Why leading zeros: from Hashcash - benchmarked to take a few seconds to write and email, but nanosecond to verify. 
    - [x] Hashcash original implementation uses [20 leading zeros](http://www.hashcash.org/dev/) - so a difficulty of [2^20 iterations](https://nakamoto.com/hashcash/). Each additional 0 doubles the number of iterations. 
        - [ ] Implementing a [hashcash server](https://replit.com/@nakamoto/Hashcash)
    * Targets average of 10 minutes per block generation time. Started at 8 leading zeros in 2009 to 18 leading zeros in 2018 > [difficulty chart](https://www.blockchain.com/charts/difficulty), [hash rate](https://www.blockchain.com/charts/hash-rate)
    * Mining pools - smoothing out economics rewards across individual miners. 
    * Pool [coordination](https://www.investopedia.com/tech/how-do-mining-pools-work/): managing the pool members’ hashes e.g. assigning ranges of nonce, looking for rewards, recording work performed by each pool member, and assigning reward shares to each pool member in proportion to the work performed - different payout strategies. Pool fees are 1-3%.
    * Network participants:
        * Full nodes: store full blockchain and can validate all txns
        * Pruning nodes - prune txns after validation and aging
        * Lightweight Nodes: simplified payment verification [(SPV)](https://en.bitcoinwiki.org/wiki/Simplified_Payment_Verification) nodes - only needs a copy of the block headers of the longest chain by querying network until longest chain is obtained
        * SPVs lets you validation your own txns w/o concern for other txns - same as a hot/cold wallet
        * Miners - perform POW and create new blocks. **Does not need to be full node** Most miners don't run full nodes, instead the operators are running full nodes. 
        * Wallets
        * Memory Pool: validated but unconfirmed transactions


- [x] [5.](https://www.youtube.com/watch?v=zGDTt9Q3vyM) Txns, UTXO, Script
    * Txn locktime (specified as block #): delays a txn from being included in a block until the specified block height (#) has passed. Used for delaying processing. 
    * Coinbase Txn: reward for solving POW. halves every 210k blocks.  
    * Coinbase Input: Block reward value, output: cannot be used as a txn input (i.e. spent) until after 100 bocks. 
    * Coinbase txns may include 100 bytes of arbitrary data 
    - [x] [UTXO](https://wiki.bitcoinsv.io/index.php/UTXO): unspent transaction output - all currently unspent txns. 
        * stored in a local database in levelDB
        * all bitcoin txns have at least 1 output (to receipient, or balance)
        * outputs are spent as inputs to other txns, must be unlocked with digital signature. 
        * UTXOs are collected into a **UTXO set** that represents current state of ownership of all BTCs in existence.
        * order: node receives txn -> node checks if input is spending a UTXO in the set (pulling additional inputs from unspent output (balance) -> ouput is taken out of UTXO set and stored in buffer -> when txn is accepted into block, UTXO is deleted from buffer
        * if txn is failed to be included in block, UTXO is returned to UTXO set.
        - [x] [Genesis upgrade in 2020](https://wiki.bitcoinsv.io/index.php/Genesis_upgrade): to reenable smart contracts, tokenization and other abilities for BTC beyond store of value.  
            * removes default block size limits for miners to customize. 
            * restore nLockTime and nSequence for Locktime (delay) features
            * disables pay-to-script PSH hash txns.
        * UTXOs offer [privacy benefits](https://river.com/learn/bitcoins-utxo-model/) by separately storeing each UTXO in a unique address, hide association between UTXO and public address. 



### Byzantine Fault Tolerance (BFT)

A BFT system is able to tolerate up to 1/3 of failing/malicious nodes

- [x] Byzantine Generals problem: [[Lamport](http://lamport.azurewebsites.net/pubs/byz.pdf)] [[Nelson](https://marknelson.us/posts/2007/07/23/byzantine.html) - defend against component failure with/without symptoms that prevent other components from reaching a consensus/agreement among themselves
    * **Also Interactive Consistency, source congruency, error avalanche, Byzantine agreement, Byzantine failure, Byzantine Fault**
    - Solution must pass three tests: termination, agreement, and validity.
        * Termination all correct processes eventually reach a decision regarding the value of the order they have been given.
        * Agreement All correct processes have to decide on the same value of the order they have been given.
        * Validity: If the source process is a correct process, all processes have to decide on the value that was original given by the source process.
    -  If the source process is faulty, all other processes still have to agree on the same value. If the General is bad, all lieutenants still have to come to a common, unanimous decision.
    - After receiving the order from source, all processes poll one anohter to check what orders each received from the source - check if source is faulty, or peer is faulty
    - Someone is lying, but _who_ is lying?
    - Naive solution: all lieutenants tell each other what the general message was, take the majority (2/3+1) solution as the correct value 
    - Lamport, Pease and Shostak Algorith: given _n_ processes of which _m_ are bad, and _n > 3m_.\
    - 1. Each lieutenant sends their own message to every other lieutenant except the general and itself (n-2). with each round, each lieutenant receives the message and its chain of participants e.g. {0, 132} - the value 0 from P1 to P3 to P2. 
    - 2. While sending messages, each lieutenant also gathers incoming messsages in a tree format - each node has 3 elements {input, path, output}. Each lieutenant calculates the majority value at each level of the tree and works up the tree. Resulting in the majority value of the root.   
    - in a n=7,m=2 where bad processes are P6,P7: 18 wrong values, 12 correct messages. 
    - Using the simple **overally majority** process in (1) will result in the wrong value. **Using a tree layout (2)**, by getting the majority in each leaf node per lieutenant, results in 4 correct messages vs 2 wrong messages. 

**BFT in Bitcoin network:** the network is asynchronous and is a replicated state machine. Participants are able to validate for bad peers or bad sources by forming a consensus based on all received-sent messages in the network and forming a 2/3 majority of the true state using POW - in which, cost of bad behavior significantly outweights good behavior, forcing a strong majority to convey true state.

- [ ] Lamport. Paxos Protocol and The [Part-Time Parliament](https://lamport.azurewebsites.net/pubs/lamport-paxos.pdf), state machine replication 


### Smart Contracts and Ethereum

> Set of promises, in digital form, including protocols, within which parties perform on promises. 
> - Nick Szabo, 1996

- [x] [6.](https://www.youtube.com/watch?v=JPkgJwJHYSc&t=9s) Smart Contracts and DApps
    - [ ] Ethereum block headers contain [3 merkle trees](https://blog.ethereum.org/2015/11/15/merkling-in-ethereum/) instead of 1 in Bitcoin, each for: Transactions, Receipts and State 
    - [ ] or rather, [**Merkle Patricia tree**](https://eth.wiki/en/fundamentals/patricia-tree)
    * Ethereum also does not have Transactions (input/outputs), but uses State Transitions
    * As as result, does not use UTXOs, but stores balances as accounts.
    * Bitcoin: transaction ledger, Ethereum: balance ledger
    - [ ] Ethereum [State Transition](https://ethereum.org/en/whitepaper/#ethereum-state-transition-function) function
    * Block time is 14 seconds, instead of bitcoin's 10 minutes
    * Hash function: Ethash, instead of SHA256. 
        * ethash [[yellowpaper App. J](https://ethereum.github.io/yellowpaper/paper.pdf)] - designed to be **ASIC-resistant and easily verifiable with light clients**. 
    * Ethereum monetary policy has changed twice from 5 > 3 > 2ETH per block. 
    * Everything in cryptography, consensus is the same as bitcoin (in POW). 

- [x] [CDC](https://digitalchamber.org/wp-content/uploads/2018/02/Smart-Contracts-12-Use-Cases-for-Business-and-Beyond_Chamber-of-Digital-Commerce.pdf) - Smart Contract Use Cases
    * Digital Identity:
        * User self-sovereignity on personal data and sharing
        * Counterparties do not store individual data, reduced liability as a point of atack
        * frictional KYC with faster verification
    * Records: 
        *  Autorenew and autorelease for compliance automation reduces legal bills
        *  Automated processes and tracking of loans and collateral value reduces error and latency in filing
        *  Data archivals automatically becomes unsearchabes/unreplayable after disposal without occying warehouse
    * Securities:
        * enables t+0 settlement cycles
        * automatic payment of dividences and stock splits, proxy/delegated voting
        * removes counterparty risks from intermediaries
    * Trade Finance / Banking :
        *  Faster approval and payments with automated comliance and monitoring of credit conditions
        *  efficiency in creating, modifying, validating trade, title, transport-related agreements
        *  increased liquidity from ease of transfer and reduced fraud
    * Derivatives:
        * automatic settlement fromo triggers of trade events
        * automated external event processing and succession
        * realtime valuation of positions for realtime exposure and reduced errors 
    * Financial Data Recording
        * improved data integrity and transparency
        * reduced expenses for accounting systems 
    * Mortgages:
        * Automated relase of liens from land records when mortgage is paid off
        * increased visibility of servicer records to all parties for verification + tracking
    * Land Title:
        * reduced audit/assurance costs and streamlined processing.
        * Reduced manual processes in closing, escrow, etc. 
        * reduce land title fraud conveyance         
    * Supply Chain:
        *   simplified complex multi-party systems delivery
        *   granularity in inventory tracking and delivery assurance for insurance and risk, reduced fraud and theft
    * Auto Insurance: 
        * vehicles communicate with eachother and exchange/validate own condition, driving record, accident report hisotry.
        * vehicle self-awareness and damage
        * reduces duplication in report and policy verification
        * interesting [projects](https://www.disruptordaily.com/blockchain-use-cases-automotive/) in development already
    * Clinical Trials and Cancer Research:
        * Improved access to cross-institution data during epidemics with privacy-preservation 
        * Consent gathering and tracking for data acccess and patient privacy 

    
- [x] [Coindesk](https://www.coindesk.com/short-guide-blockchain-consensus-protocols): Short Guide to Blockchain Consensus Protocols e.g. POA, POS, POB, POC, POET. 
    * POS: no miners, instead validators/stakeholders and selected by stake size and paid in fees. Blocks are signed, and requirements differ between POS systems. 
    * PoActivity: Miners mine blocks (POW), blocks do not contain txn + random Validators sign on block (POS). If all selected validators are not available, new block + validators are reselected. Fees are split between minters and validators that complete a full block. 
    * PoBurn: miners burn native or alternative currency. More coins burned, higher chance of selection to mine. Burning coins is similar to spending compute power in POW. 
    * PoCapacity: pay with storage. More storage, higher chance of mining. Storage is used for data sets (plots). 
        - [ ] Proofs of Space: [whitepaper](https://eprint.iacr.org/2013/796.pdf)
    * Proof of Elasped Time (Intel): blocks are produced in random lottery using [TEE](https://en.wikipedia.org/wiki/Trusted_execution_environment)
        * TEE: isolated execution env with higher level of security.
        * TEE use cases: protects content on a device, no exposed to app developer or platform vendor. e.g. isolates application from mobile OS, infrastructure. 

- [x] PlanB: modeling Bitcoin's value with [Scarcity](https://medium.com/@100trillionUSD/modeling-bitcoins-value-with-scarcity-91fa0fc03e25) (Stock-to-Flow, S2F modelling)
    * _unforgeable costliness, scarcity_
    * _existing stockpiles of btc in 2017 was 25x minted btc.
    * stock = reserves, flow = production/mint. supply growth rate = flow/stock. SF = 1/supply growth.
    * Gold SG: 62, silver SF: 22, Palladium: 1.1, Platinum: 0.4. 
    * BTC 2021 supply: 18.73M BTC, flow: 900 BTC/day, S2F: 57. [stats](https://www.blockchain.com/charts#currency)
    * different models take into account lost BTC supply, original 1M minted by Satoshi etc. 
    * where would money inflow to BTC market value come from? other commodity markets and economies. 
    * validating that BTC is driven by SF using power law: **Market value = exp(14.6) * SF^3.3**. 
    * power law: change in P results in exponential change in Q independent of size. 
    * BTC market crashes in 2011, 2014, 2018 are in different scales (10, 1000, 10000). 


- [x] 2018. Bitcoin, the [Mises Regression Theorem](https://mises.org/library/bitcoin-regression-theorem-and-emergence-new-medium-exchange) and emergency of a new medium of exchange 
    * Mises Regression Theorem: a _money_ is a _good_ with objective value from its own direct use, becomes later valued as function in indirect excahnge. 
    * condition that no MOEx exists in that economy (completely barter economy)
    * _Is bitcoin money, and does it refute the MRT?_: whether MRT is applicable to cryptocurrencies, which are not backed by any commodity. 
    * Faggart: _we must.. identify when bitcoin went from being a “consumer good” to being used in indirect exchange_
    * Suede, Murphy: Object does not need to be valued directly before being a MOEx. 
    * Critics: Paper money replacing paper money - German Rentenmark, the Euro, Argentinian Credito (over Peso). Psychological factors, legal tender laws, government assurance and redeemability against older currencies make it possible for new money against the MRT. 
    > _Does BTC violate MRT?_: _analyzing the actors’ motivations, and the factors that induced their confidence is beyond the scope of the regression theorem or any praxeological discussion_
    * if BTC becomes money, it is the first **non-commodity money in absence of legal-tender laws**, govt and institutional backing
    * Surda: the _truly unique functions of BTC are non-monetary_: effective notarization, smart prperty, conditional transfers, eliminates intermediaries, form stock ownership, transaction aduiting. 
    * Mises: once a medium is accepted by the public as money, its underlying direct use (e.g. jewelry for gold and silver) can disappear entirely. 
    * _Bitcoin does not need to have a direct-use value in order to be a medium of exchange, because it did not emerge from a pure barter economy_
    - [x] El Salvador passes Bitcoin as [legal tender](https://twitter.com/nayibbukele/status/1402446890466217985)
    * BTC and USD exchange rate is freely established by the market
    * Prices and tax can be paid in BTC. All economic agent must accept BTC as payment
    * BTC exchanges are not taxed as capital gains as it is legal tender. 
    * Accounting remains in USD. 
    * State guarantees a Trust for auto/instant conversion of BTC-USD. 

- [x] [7.](https://www.youtube.com/watch?v=GLVrOlHLJ1U) Technical Challenges
    * Centralization vs Decentralization (Coase): Costs of Capture, Rents, SPOF vs Costs of Coordination, governance, security, stability moves market preference. 
    * VB Trilemma: scalable, decentralized, secure. _working enough_. 
    * Sidechain analogous to commercial banks settling with central bank.
    * Sidechains validate txns and block - mainchain validates the chain state after _condensation_ 
    - [ ] 21st Geneva Report: Blockchain on Finance [paper](https://voxeu.org/content/impact-blockchain-technology-finance-catalyst-change)
    * hard forks: software updates which are not backwd compatible because older sw version cannot validate new blocks e.g. change in block size. 

- [x] Shyft Network: Understanding [Trie Databases](https://medium.com/shyft-network-media/understanding-trie-databases-in-ethereum-9f03d2c3325d) in Ethereum
    * Tree: data struct, hierarchical linked nodes. _Trie_: tree-like data structure to hold an associative array i.e. re***trie***ve. _Tries_ are also claled prefix trees, radix trees or digital trees.
    * Tries: retrive a string value by traversing down a branch of nodes that store assoicated references/keys that lead to end value. 
    * keys with same sequences are grouped in close proximity to reduce time to travel down a branch. keys can be strings of characters instead of individual characters to improve efficiency in value look-up.
    * merkle trees: leaf nodes - hash of block, non-leaf nodes - hash of the labels of children. 
    * merkle tree properties: consistency/verification + fast to verify + only requires part of the tree for verification (starting from root, check hashes of only subtree)
    * light clients can also perform verification - light clients receive merkle root in block headers, which can be used to query full nodes for verification.
    * **Modified Merkle Patricia Trie**: cyrptographically authenticated - Deterministic: a trie with same (k,v) is guaranteed to be exactly the same. _cryptographically secure_.
    * each node is referenced by hash for leveldb/rocksdb lookup. root nodes are a cryptographic fingerprint of _entire_ data structure to speed up insert/lookup/delete. 
        * leveldb features: 
            * data is stored and sorted by keys. 
            * caller-custom comparison functions. 
            * ordered mapping from string keys to string values
            * multiple changes in single atomic batch 
            * fwd/bkwd iteration
            * autocompressions using snappy
    * **Hex-prefix (HP) encoding**: encoding _paths_ between trie nodes - (1) disambiguate leaf vs extension nodes, (2) convert path to even length for tree to be a _whole number of bytes_.
        *  Node types: 
            *  (1) Leaf - has a terminator/flag - the last byte of the path. 
            *  (2) Extension. 
        *  In encoding, Nibbles (single-hex) may be used to ensure path is always an _even_ length.
            *  Odd-length extensions are prepended with nibble
            *  even-length leafs: i. terminator is removed, ii. added with 2 hexes for even-length
            *  odd-length leafs: i. terminator is removed
    *  **Recursive Length Prefix (RLP)**: encoding _value_ / data serialization, planned to be replaced with new serializer.
        * encode nested arrays / byte array (item) or list of item.
        * Node types: 
            * `NULL`: empty string
            * `BRANCH`: 17-item node looks like [v0,..v15, vt]
            * `LEAF`: [encodedPath, value]
            * `EXTENSION`: [encodedPath, key]
        *   extension nodes are used for skipping ahead nodes with no differing paths or index values, using a _partial path_ for lookups
    *  **Ethereum Tries**: root for each tree is Keccak-256 hash, and **Receipt+State+Transaction Trees are in the block header.** Storage Tree root is in the RLP encoded value. 
        * (1) Transaction Tree: records transactions. Input params (account nonce, gas, recipient, transfer value etc.)
        * (2) Receipt Tree: records txn outcomes, used for ZKPs and searches. Input params (post-txn state, gas used, logs, log bloom filter)
        * (3) State Tree: global state trie, contains [ethereum address, RLP-encoded account (nonce, blanace, root, hash)]. Constantly updated.
        * (4) Storage Tree: contract data, each account has a separate storage trie. 


## Consensus: Proof of Work, Proof of Stake

### Hashcash

- [ ] Back, Adam. Hashcash - Denial of Service [Counter Measure](http://hashcash.org/papers/hashcash.pdf)
  * _Interactive_ v. _non-interactive cost-functions: CHAL, MINT, VALUE
- [ ] Back, Adam. Hashcash - Amortizable Publicly Auditable [Cost-Functions](http://hashcash.org/papers/amortizable.pdf)

### POS and Ethereum 2.0

- [ ] [Ethereum.org](https://ethereum.org/en/developers/docs/consensus-mechanisms/pos/): Proof of stake
- [ ] [Consensys](https://consensys.net/blog/blockchain-explained/what-is-proof-of-stake/): what is proof of stake?
- [ ] Ethereum's Casper Algorithm: [coindesk](https://www.coindesk.com/ethereum-casper-proof-stake-rewrite-rules-blockchain) [ChainSafe systems](https://medium.com/chainsafe-systems/ethereum-2-0-a-complete-guide-casper-and-the-beacon-chain-be95129fc6c1)
    - [ ] VB. [Slasher](https://blog.ethereum.org/2014/01/15/slasher-a-punitive-proof-of-stake-algorithm/): Punitive Proof of Stake Algorithm
- [ ] [ethash design](https://zerocrypted.com/what-is-ethash/) and resisting mining dependency
- [ ] Wall, Eric. Proof of Stake is less [wasteful](https://ercwl.medium.com/proof-of-stake-is-less-wasteful-b2854a191766)
  - [ ] Sztorc, Paul. Nothing is Cheaper than Proof of [Work](https://www.truthcoin.info/blog/pow-cheapest/)
- [ ] BitFury: POS vs POW [whitepaper](https://bitfury.com/content/downloads/pos-vs-pow-1.0.2.pdf)

### L2 and Sidechains

- [ ] MIT: The [Lightning Network](https://dci.mit.edu/lightning-network/)
- [ ] Introducing Arbitrum [One](https://offchain.medium.com/introducing-arbitrum-one-our-mainet-beta-ed0e9b63b435)
- [ ] [AVM](https://developer.offchainlabs.com/docs/avm_design) design rationale
- [ ] Beginner-friendly tutorial to Matic.js [Polygon](https://blog.polygon.technology/beginner-friendly-tutorial-to-matic-js-58f7c24c9744)

#### State Channels

- [x] [EthHub](https://docs.ethhub.io/ethereum-roadmap/layer-2-scaling/state-channels/) 1. State is locked via multisig or smart contract with specified participants
        * participants update state among each other by constructing and signing txns without submitting to blockchain
        * submit state back to blockchain and close state channel and unlocks state

| State Channels | Side Chains |
|:---------|:------|
| * privacy - limits visibility betw. channel participants| * all txns are published in sidechain |
| * instant finality, signed state in a s. channel can be considered final || 
| * 100% participants in the multisig must be available. | |
| * best for known participants - can be added/removed with new contracts | * no limitation on participant changes |
| * best for multiple state updates over a longer period of time due to initial cost to create a channel ||
|| * sidechains are permanent (no need to close). assets are locked on sidechain to move back to mainchain. |
|| * since participants can be added/removed, there's no need for new chains |
|| * sidechains do not share security with mainchain - users on sidechains must trust the security of the sidechain itself. sidechains must have enough miners on their network unlike state channels |
||* sidechains need federation - additional layer (servers) as intermediate points between main chain and sidechain to lock/release coins.  |

- [ ] [VB.](https://vitalik.ca/general/2021/01/05/rollup.html) State channels vs plasma vs rollups

- [ ] On [Sharding Blockchains](https://eth.wiki/sharding/Sharding-FAQs)


- [ ] Cardano's POS algorithm: [Ouroboros](https://cardano.org/ouroboros/) 
   - [ ] _Provably Secure protocol_: [whitepaper](https://eprint.iacr.org/2016/889.pdf)
- [ ] Solving the Blockchain [Trilemma](https://www.coinbureau.com/analysis/solving-blockchain-trilemma/)
- [ ] IOHK: Performance Engineering - Lies, Damned Lies and [TPS Benchmarks](https://www.youtube.com/watch?v=gpSnyCn2s9U)


## Understanding Curve 

_Invariant_ is a property of a mathematical object (or a class of mathematical objects) which **remains unchanged** after operations or transformations of a certain type are applied to the objects

- [x] [StableSwap Exchange](https://curve.fi/files/stableswap-paper.pdf) for stablecoin / pegged-assets liquidity
    * low price slippage (1/100x Uniswap) for demands, multi-stablecoin savings account with 300% APR for supply. 
    * Sigma and Pi [Notation](https://mathmaine.com/2010/04/01/sigma-and-pi-notation/)
    * Constant Product for ETH etc. Constant sum for stables. Constant Product MMs have higher slippage and very small returns for stables. 
    * given two coins x, y: dy/dx is price. slippage_x is dy/dx against dx or d2y/dx2
    * Amplified or leveraged invariant: d2y/dx2 -> 1 when dx -> 0, d2y/dx2 -> 1/x when dx -> inf. 
    * ![amplified invariant](../assets/amplified_invar.png)
    * low leverage: market is constant product (high slippage). high leverage: market is constnat sum (low slippage)
    * **at high leverage, market is constant sum (low slippage). which is good for stables.**
    * taking χ as a dynamic value: constant A x Constant Product function. Converge for D (total coins at equal price)
    - [x] Converging D [code using Newton method](https://github.com/curvefi/curve-crypto-contract/blob/master/contracts/CurveCryptoMath3.vy#L90)
    * ![stableswap invariant](../assets/stableswap_invar.png)
    - [x] SerenityFund: the Magic [Amplification Coefficient](https://serenityfund.medium.com/company-watch-curves-formula-for-stablecoins-swap-and-the-magic-amplification-coefficient-d998ed1e184b)
    * Large A for coins that are unlikely to peg. INF A becomes [mStable](https://app.mstable.org/#/musd/save), all tokens are 1:1 swaps.
- [x] [Pools](https://curve.readthedocs.io/exchange-pools.html#exchange-pools-a)
    * Amplification coefficient: The amplification co-efficient (“A”) determines a pool’s tolerance for imbalance in its assets. implemented as 1/A - higher A values means the pool allows for **less** slippage when imbalance is high. 
    * Plain pools: stablecoins pool. 
    * Lending pools: wrapped tokens, underlying asset is lent out to e.g. aave, yearn, compound
    * Metapools: stablecoin + LP token e.g. gUSD + 3CRV (from 3Pool plain pool) for additional trading fees. 

- [ ] [Constant Function](https://medium.com/bollinger-investment-group/constant-function-market-makers-defis-zero-to-one-innovation-968f77022159) Market Makers (CFMMs) vs AMMs: 
    * CFMMs as a subset of AMMS
    * Bonding curves: relationship between price - **token supply**. CFMMs use relationship between **two or more tokens**, so not a bonding curve. 
    * Constant Functions _def._ any trade exchanges must **conserve the overall reserve (constant)**. Abitrageurs maintain price of assets within that portfolio based on market price.
    * Constant Product: 
    * Constant Sum (x+y)=k: 
    * Constant Mean:
    * Hybrid CFMMs:

- [ ] Relevant Community: What are [Bonding Curves](https://blog.relevant.community/how-to-make-bonding-curves-for-continuous-token-models-3784653f8b17)

### Curve V2

Objectives: 

* _liquidity for assets which aren’t interpegged, but more efficient than xy = k_
* liquidity concentration with current dynamic _internal oracle_ price, changes when loss is smaller than system profit. for 5-10x higher liquidity. 
* Amplification factor A and gamma are autoadjusted for converging on invariant D. 
* fees are dynamic
* 

- [x] AMM with [dynamic peg](https://curve.fi/files/crypto-pools-paper.pdf)
    * Invariant is represented as a _hypersurface_: ordinary surface in three-dimensional space to the case of an n- dimensional space.
    * _When we change (price coefficients), the price peg (between all tokens in pool) changes but balances of each token don't._ 
    * _We can calculate the invariant D for the new values of (transformed balance) and substitute new D and (price coefficients) to calculate (cost/profit). 
    * We allow the reduction in Xcp (cost/profit) but only such that the loss of value of Xcp (cost/profit) doesn’t exceed half the profit we’ve made (which we track by tracking
the increase of Xcp)._
    * CurveCrypto invariant: 
    * ![curvecrypto_invar](../assets/curvecrypto_invar.png)
    * the leverage variable χ from stableswap, is this, **K**, is a function of A (amplification) and γ (distance of two constant product functions)(small value)
    * ![new_leverage_function](../assets/new_leverage_function.png)
    * for a pool of coins xi, we calculate for D. 
    * _safe values for converging D: `1<A<10E4, 10E-9 < x0 (based currency) <10E15, 10E-5 < xi/x0 (price ratios) < 10E5, 10E-8 < γ < 10E-2`_
    * e.g. in stableswap paper, for χ= 30000, optimal A=85.  
    * p (coefficients) are adjusted when the last real Xcp (cost/profit) is less than last calculated 0.5 x Xcp (from internal price oracle). 
    * ![cost-profit-function](../assets/cp_function.png)
    * The internal price oracle is an EMA by N-dimensions of prce. 
    
- [x] curvecrypto [contract](https://github.com/curvefi/curve-crypto-contract/blob/master/contracts/matic/CurveCryptoSwapMatic.vy)
    * [`add_liquidity`](https://github.com/curvefi/curve-crypto-contract/blob/master/contracts/CurveCryptoSwap.vy#L707), `remove_liquidity` calls `tweak_price`
    * `tweak_price` parts: 
        * updates oracle EMAs: [alpha](https://github.com/curvefi/curve-crypto-contract/blob/master/contracts/CurveCryptoSwap.vy#L461)
        * calculates initial `newton_D` for 35k gas 
        * updates oracle prices or calculates from initial price_list for 70k gas for 3-token pool.
        * calculate new profit using virtual_price
        * recalculates new `newton_D` for change in [balance*prices]
        * checks for price adjustments, or virtual_price > profit + `ALLOWED_EXTRA_PROFIT`
        * or, readjust for new price prices, price_threshold must be more than adjustment_step
        * recalculate D from A, gamma, price_list until gets new profit with new parameters.
        * recalculate new prices xp
        * recalculate virtual_price from geometric mean of xp: see _Quantification of a repegging loss_
        * update parameters: D, price_scales, virtual_price.



## Defi Security 

- [x] The Fvckrender hack [post-mortem](https://manifoldxyz.substack.com/p/the-fvckrender-hack-post-mortem 

## Governance

- [x] UniV3 on Arbitrum [vote](https://gov.uniswap.org/t/deploy-uniswap-v3-to-arbitrum-mainnet/12451) [passed](https://snapshot.org/#/uniswap/proposal/Qmehop1NNWP9VEf7tGLEAYRphVsXtdxkL7oKEhaXL2Xao6)
    * Univ3 is licensed under [BSL 1.1](https://uniswap.org/blog/uniswap-v3/) - no forks up to 2 years. 
    * Current plans for integration with Optimism, but Arbitrum has far less risk of reaching a non-deterministic state and it can be used with the same contract bytecode as used for Ethereum L1 contracts.
    - [x] Optmism vs Arbitrum: 
        * L2s, optimistic (fraud proofs), sequencers
        * difference. - what happens when two partieis disagree on a state
        * Optimism: single round fraud proofs: L1 executes whole L2 on-chain for verification for instance FP (fraud-proofing) (containerization)
        * Arbitrum: multi round fraud proofs: binary search to find first opcode of a contended block in AVM. Slower between 1-2 weeks for FP. (virtualization)
        * Optimism FP may not support hardforks, opcodes may be removed or modified. 
- [x] UniV3 on xDai [vote](https://gov.uniswap.org/t/deploy-uniswap-v3-to-xdai-chain/12508) [open]
    * xDai - latest EVM patchset (berlin) and supported by 2 clients: openEth and Nethermind. dPoS
    *  multichain interop with distributed governance board
    *  increased block capacity by 30% 
    *  xDai [omnibridge](https://omni.xdaichain.com/bridge)


## How to DeFi

- [ ] The Vaults at Yearn [(June 3rd 2021)](https://medium.com/yearn-state-of-the-vaults/the-vaults-at-yearn-9237905ffed3)
   * yveCRV-DAO / [backscratcher]: takes CRV, additional fee earnings on top of staking in curve. claimed as 3crv
- [ ] Seba Bank on [Yearn Finance](https://www.seba.swiss/research/yearn-finance-decentralised-asset-management)
- [x] [Bloomberg](https://archive.is/2021.06.07-093617/https://www.bloomberg.com/news/articles/2021-06-07/bitcoin-btc-vs-ethereum-eth-and-defi-there-s-a-big-difference) on DeFi
- [x] Quickswap QUICK [tokenomics](https://quickswap-layer2.medium.com/quick-tokenomics-liquidity-mining-details-96-75-distributed-to-the-community-3dbffd6ba214): 90% liquidity mining over 4 years, 5% to UNI LPs, 3.25% to creators, 1% for future airdrop, 0.75% marketing
- [x] Everything about [dQUICK](https://quickswap-layer2.medium.com/everything-you-need-to-know-about-dquick-the-dragons-lair-e2df6fb861af)
    *  0.04% (out of the 0.30% fee) of volume trades are used to market buy QUICK and distribute it to dQUICK stakers. 
    - [x] [Contract](https://explorer-mainnet.maticvigil.com/address/0xf28164A485B0B2C90639E47b0f377b4a438a16B1/contracts) + [extract](../code/dquick.sol)
- [x] Coindesk: Making Sense of [CryptoEconomics](https://www.coindesk.com/making-sense-cryptoeconomics)    
    * [mechanism design](https://en.wikipedia.org/wiki/Mechanism_design): economics and game theory in desining mechanism or incentives where players act rationally. 
    * Cryptoeconomics requires us to think about information security problems in economic terms. _Security guarantee in a distributed system_
    * 1. Consensus protocols: including Eth resistance to mining centralization
    * 2. Application tokenomics
    * 3. State channels: moving cheaper processes off-chain before sending the final state to blockchain


## Unsorted

- [x] Ruby [Sidekiq](https://longliveruby.com/articles/sidekiq-good-practices) best practices

## General News

- [x] Rundown on FBI "recovery" of DarkSide Colonial Pipeline [hack](https://dossier.substack.com/p/the-colonial-pipeline-hack-the-russians)
    * DOJ claims to have _hijacked DarkSide's Bitcoin wallet_ to seize 63.7 BTC.
    * DOJ actually traced and issued warrant to a custodian wallet based in NorCal, most likely an exchange. 
    * Note that US-regulated exchanges are KYC-ed and do not serve Russian users (DarkSide is allegedly Russian)

- [x] Snapshot: decentralized [voting](https://decrypt.co/resources/what-is-snapshot-the-decentralized-voting-system)
    * uses IPFS without on-chain verification, making voting fee-less.
    * voting with NFTs
    
- [x] Bitcoin 2021: Letter from Julian Assange - excerpt from [Cypherpunks: Freedom and the future of the internet](https://www.youtube.com/watch?v=_KgEjRKTZ9A) [book](https://www.amazon.com/Cypherpunks-Freedom-Internet-Julian-Assange/dp/1944869085)
    *  Assange Defense Fund: [Official Links](https://defend.wikileaks.org/donate/), [GoFundMe](https://www.gofundme.com/f/julian-assange-amp-wikileaks-public-defense-fund/update/26498466/gallery/0)
