# EthKL Gathering

## 1. Optimistic Rollups
off-chain processing for high tps, BUT on-chain dispute resolution
Started from state/payment channels, then plasma, then optimistic

- https://medium.com/omgpool/plasma-vs-optimistic-rollups-9808c2f64975
- collection of contracts, stores off-chain data e.g. state root, txn data in calldata
- activities in call data: not reexceted in L1, and is not bound to L1
- can re-exec txn if state root if correct
- https://www.alchemy.com/overviews/optimistic-rollups
- use off-chain components (code) for computation and stores full off-chain state data

#### Components:
- collection of contracts (different roles: rollup, sequencer, challenge manager etc.): https://developer.arbitrum.io/useful-addresses
- sequencer: orders transactions, batching and submitting them to L1. https://cryptoatlas.net/50-what-is-a-sequencer-in-optimism.html


#### Costs:
1. L2 computational cost
2. L1 storage cost - fixed (base and state write) + variable cost (16 gas per byte calldata)
3. activity on L2 does not affect cost of batch submission on L1. 
4. Dynamic fees on L1 is handled by a gas oracle or L1 pricer to estimate L1 base fee. 


See on Arbiscan: 
- Poster fee 
- Network fee: gas fee

#### Batches:
- Optimism uses state batches vs transactions batches. Arbitrum has batches that bundle both state and txn into a single contract
- You can parse thed ata, figure out what is happening off-chain and end up with the same state root (conclusion) as off-chain component. 

Calldata explorer: https://l2fees.info/blog/rollup-calldata-compression


#### Fraud Proof:
1. arbitrum fraud proof tested during ethw fork: https://twitter.com/plasmapower0/status/1588206033654145024
2. fraud proofs (interactive or non-int) - **prevent invalid state transition from being confirmed as canonical on rollup contract)**
3. OP (NIFP) - has a simulation of the EVM, state validatity can be computed independently
4. Arbi (IFP) - brings re-exec and dispute identification off-chain than on-chain
5. FP isnt live on optimsm. Arbiturm rules sole, centralized sequencer
6. Cannon - optimism next-gen FP: https://medium.com/ethereum-optimism/cannon-cannon-cannon-introducing-cannon-4ce0d9245a03
7. if there is an invalid, someone needs to submit a txn to challenge the submitted state
8. Is it possible to prevent the FP from reaching the contract? Yes, by bribing a large set of validators. But one honest validate would include the txn. 
	- but spam attacks will be prohibitively expensive 
	- technically possible, but unlikely/not rational
9. what is a transacation finality on optimistic rollups?
	- accepted by sequencer - tusts it will be published
	- published as a batch - L1 sec guarantees, but 7d FP window 
	- Past 7 day FP window. not reversible

##### Arbitrum FP
1. arbitrum FP: https://medium.com/offchainlabs/fraud-proofs-and-validators-how-you-or-anyone-can-keep-arbitrum-honest-d68add3f6c5d
2. correctness of Arbitrum requires **only that one honest party is validating**
3. arbi validators can choose 1 of 3 strategies: active validator, defensive validtor, watchtower validator. read more on it
4. usually only 1 active validator at a time, then the others will take a defensive strategy
5. def and watchtow validators will privately check each block proposed is valid
6. who would validate? initial set of paid validators, parties with significant staked assets, or anybody else (good citizens). but most ordinary users don't need to.


##### Arbitrum Fees:
1. https://medium.com/offchainlabs/understanding-arbitrum-2-dimensional-fees-fd1d582596c9
2. 


## ZK
1. https://zkrepl.dev/
2. https://blog.chain.link/zero-knowledge-proof-projects/
2. 3 properties: Completeness, Soundness, Zero-knowledgeness
3. interactive vs non-interactive: NI proofs allows proving and verification w/o constant or frequent interaction. 
	- IP -> IZKIP -> NIZKP
4. SNARKS vs STARKS types of proofs
	- each type of proof has different proof systems, different ways of generating a proof e.g. different proof time, recursions e.g. used in different protocols
		+ SNARKs: Halo2, kimchi, Plonk. 
		+ STARK
5. SNARK: elliptical curves, allows generated proofs to be short/succinct.
6. https://consensys.net/blog/blockchain-explained/zero-knowledge-proofs-starks-vs-snarks/
7. circom - programming lang for snark
8. https://learn.0xparc.org/materials/circom/demos-learning-group-1/zkrepl/
	- A Poseidon hash is used ot create a hash: https://www.poseidon-hash.info/
	- Intro to Circom: https://github.com/Phonbopit/intro-to-circom
	- Circom is a language to write circuits to generate proofs
	- Cairo is a general programming language that converts into a ZK proof, to prove the computation is correct



## BRC 20
https://milkroad.com/brc-20-tokens

